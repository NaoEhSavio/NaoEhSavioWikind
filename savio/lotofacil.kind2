List.fold <x> <y> (func: x -> y -> y) (l: List x) (b: y) : y
List.fold func List.nil  b = b
List.fold func (List.cons l head tail) b = (func head) (List.fold func tail b)

List.length <a> (xs: List a) : U60
List.length a (List.nil t)            = 0
List.length a (List.cons t head tail) = (+ (List.length a tail) 1)

List.delete_all (v: U60) (s: List U60) : List U60
List.delete_all v (List.nil) = List.nil 
List.delete_all v (List.cons  head tail) = if (U60.equal v head) {(List.delete_all v tail)} else {(List.cons U60 head (List.delete_all v tail))}

List.filter <a> (xs: List a) (cond: a -> Bool) : List a
List.filter a (List.nil t)            cond = List.nil
List.filter a (List.cons t head tail) cond =
  if cond head {
    List.cons head (List.filter tail cond)
  } else {
    List.filter tail cond
  }

List.concat <a> (xs: List a) (ys: List a) : List a
List.concat a (List.nil t)            ys = ys
List.concat a (List.cons t head tail) ys = (List.cons a head (List.concat a tail ys))

U60.to_bool (n: U60) : Bool
U60.to_bool 0 = Bool.false
U60.to_bool n = Bool.true

List.u60.filter.go (cond: U60 -> U60) (eql: U60)  (xs: List U60)  : List U60
List.u60.filter.go cond eql (List.nil t)         = List.nil
List.u60.filter.go cond 0 (List.cons t head tail) = (List.u60.filter cond tail)
List.u60.filter.go cond 1 (List.cons t head tail) = (List.cons head (List.u60.filter cond tail))

List.u60.filter (cond: U60 -> U60) (xs: List U60)  : List U60
List.u60.filter cond (List.nil t)         = List.nil
List.u60.filter cond (List.cons t head tail) =
	let eql = (cond head)
	List.u60.filter.go cond eql (List.cons t head tail)

// Quick sort : List -> List
Quick.sort (xs: List U60) : List U60
Quick.sort List.nil = List.nil
Quick.sort (List.cons x xs) =
  let min = Quick.sort (List.u60.filter (n => (< n x)) xs)
  let max = Quick.sort (List.u60.filter (n => (> n x)) xs)
  (List.concat min (List.cons x max))



// Bubble sort : List -> List
Bubble.sort (xs: List U60) : List U60
Bubble.sort List.nil         = List.nil
Bubble.sort (List.cons t x xs) = (Insert x (Bubble.sort xs))

// Insert : U60 -> List -> List
Insert (v: U60) (xs: List U60)  :  List U60
Insert v List.nil            = (List.cons v List.nil)
Insert v (List.cons t x xs)  = (GoDown (> v x) v x xs)

// GoDown : U60 -> U60 -> U60 -> List -> List
#partial
GoDown (b: U60) (v: U60) (x: U60) (xs: List U60) : List U60
GoDown 0 v x xs = (List.cons v (List.cons x xs))
GoDown 1 v x xs = (List.cons x (Insert v xs))

Loto.soma (xs: List U60) : U60 {
	List.fold (a => b => (+ a b)) xs 0
	}
Loto (xs: List (List U60)) : List U60
Loto (List.nil) = List.nil
Loto (List.cons xs head tail) = 
	let h = Loto.soma head 
	let t = Loto tail
	List.cons h t

Porcent (xs: List U60) : List (List U60)  {
	Porcent.go xs (List.length xs)
}
Porcent.go (xs: List U60) (len: U60) : List (List U60) 
Porcent.go (List.nil xs) len = List.nil
Porcent.go (List.cons xs head tail) len = 
	let eql = (List.length (List.filter (List.cons xs head tail) (a => (U60.equal head a))))
	let por = (/ (* 1000000 eql) len)
	let par = List.cons head (List.cons eql [por])
	let del = List.delete_all head (List.cons xs head tail)
	let res = Porcent.go del len
	List.cons par res

Nat.factorial (n: Nat): Nat 
Nat.factorial  Nat.zero    = Nat.one
Nat.factorial (Nat.succ n) = Nat.mul (Nat.succ n) (Nat.factorial n)

U60.interval (start: U60) (stop: U60) (step: U60) : List U60{
	U60.if (>= start stop) (List.nil U60) (
		List.cons (+ start step) (U60.interval (+ start step) stop step)
	)
}
U60.fac (n: U60) : U60
U60.fac 0 = 1
U60.fac n = (* n (U60.fac (- n 1)))

U60.if <r: Type> (n: U60) (t: r) (f: r) : r
U60.if r 0 t f = f
U60.if r n t f = t

#partial
U60.combination (n: U60) (p: U60) : U60
U60.combination n 0 = 1
U60.combination n 1 = n
U60.combination n p = 
let aux = U60.if (> (- n p) p) (- n p) p
U60.if (>= n p) (/ (List.fold (a => b => (* a b)) (U60.interval aux n 1) 1) (U60.fac (- n aux))) (0)







Main {
let a = [[02,03,04,05,07,08,10,11,12,14,15,20,22,23,24],
[02,03,05,06,09,10,11,13,15,16,17,19,21,22,24]]
	let b = Loto a
	let c = Quick.sort b
 	let d = Porcent c 
	let f = U60.combination 25 15
	f
	
}