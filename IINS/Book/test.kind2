type BinaryTree (t) {
  Leaf
  Node (val: t) (lft: (BinaryTree t)) (rgt: (BinaryTree t))
}

BinaryTree.set <a> (key: Data.Bits) (val: a) (btree: BinaryTree a) : (BinaryTree (Data.Maybe a))
BinaryTree.set a (Data.Bits.e) val (BinaryTree.Leaf) = BinaryTree.Node (Data.Maybe.some val) (BinaryTree.Leaf) (BinaryTree.Leaf)
BinaryTree.set a (Data.Bits.o pred) val (BinaryTree.Leaf) = BinaryTree.Node (Data.Maybe.none) (BinaryTree.set pred val (BinaryTree.Leaf)) (BinaryTree.Leaf)
BinaryTree.set a (Data.Bits.i pred) val (BinaryTree.Leaf) = BinaryTree.Node (Data.Maybe.none) (BinaryTree.Leaf) (BinaryTree.set pred val (BinaryTree.Leaf))
BinaryTree.set a (Data.Bits.e) val (BinaryTree.Node value lft rgt) = (BinaryTree.map (x => Data.Maybe.some x) (BinaryTree.Node val lft rgt))
BinaryTree.set a (Data.Bits.o pred) val (BinaryTree.Node value lft rgt) = BinaryTree.set.lft value (BinaryTree.set pred val lft) rgt
BinaryTree.set a (Data.Bits.i pred) val (BinaryTree.Node value lft rgt) = BinaryTree.set.rgt value lft (BinaryTree.set pred val rgt)

BinaryTree.set.lft <a> (val: a) (lft: (BinaryTree (Data.Maybe a))) (rgt: BinaryTree a) : (BinaryTree (Data.Maybe a))
BinaryTree.set.lft a val lft rgt = (BinaryTree.Node (Data.Maybe.some val) lft (BinaryTree.map (x => Data.Maybe.some x) rgt))

BinaryTree.set.rgt <a> (val: a) (lft: BinaryTree a) (rgt: (BinaryTree (Data.Maybe a))) : (BinaryTree (Data.Maybe a))
BinaryTree.set.rgt a val lft rgt = (BinaryTree.Node (Data.Maybe.some val) (BinaryTree.map (x => Data.Maybe.some x) lft) rgt)

BinaryTree.get <a: Type> (key: Data.Bits) (btree: BinaryTree a) : (Data.Maybe a)
BinaryTree.get a (Data.Bits.e) (BinaryTree.Leaf) = (Data.Maybe.none)
BinaryTree.get a (Data.Bits.o pred) (BinaryTree.Leaf) = (Data.Maybe.none)
BinaryTree.get a (Data.Bits.i pred) (BinaryTree.Leaf) = (Data.Maybe.none)
BinaryTree.get a (Data.Bits.e) (BinaryTree.Node value lft rgt) = (Data.Maybe.some value)
BinaryTree.get a (Data.Bits.o pred) (BinaryTree.Node value lft rgt) = (BinaryTree.get pred lft) 
BinaryTree.get a (Data.Bits.i pred) (BinaryTree.Node value lft rgt) = (BinaryTree.get pred rgt)

BinaryTree.mut <a: Type> (key: Data.Bits) (func: a -> a) (btree: BinaryTree a) : (BinaryTree a)
BinaryTree.mut a (Data.Bits.e) func (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.mut a (Data.Bits.o pred) func (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.mut a (Data.Bits.i pred) func (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.mut a (Data.Bits.e) func (BinaryTree.Node value lft rgt) = BinaryTree.Node a (func value) lft rgt
BinaryTree.mut a (Data.Bits.o pred) func (BinaryTree.Node value lft rgt) = BinaryTree.Node a value (BinaryTree.mut pred func lft) rgt
BinaryTree.mut a (Data.Bits.i pred) func (BinaryTree.Node value lft rgt) = BinaryTree.Node a value lft (BinaryTree.mut pred func rgt)

BinaryTree.app <a: Type> (key: Data.Bits) (func: a -> a) (init: a) (btree: BinaryTree a) : (BinaryTree a)
BinaryTree.app a (Data.Bits.e) func init (BinaryTree.Leaf) = BinaryTree.Node a (func init) (BinaryTree.Leaf) (BinaryTree.Leaf)
BinaryTree.app a (Data.Bits.o pred) func init (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.app a (Data.Bits.i pred) func init (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.app a (Data.Bits.e) func init (BinaryTree.Node value lft rgt) = BinaryTree.Node a (func value) lft rgt
BinaryTree.app a (Data.Bits.o pred) func init (BinaryTree.Node value lft rgt) = BinaryTree.Node a value (BinaryTree.app pred func init lft) rgt
BinaryTree.app a (Data.Bits.i pred) func init (BinaryTree.Node value lft rgt) = BinaryTree.Node a value lft (BinaryTree.app pred func init rgt)

BinaryTree.del <a: Type> (key: Data.Bits) (btree: BinaryTree a) : (BinaryTree a)
BinaryTree.del a (Data.Bits.e) (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.del a (Data.Bits.o pred) (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.del a (Data.Bits.i pred) (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.del a (Data.Bits.e) (BinaryTree.Node value lft rgt) = (BinaryTree.Leaf)
BinaryTree.del a (Data.Bits.o pred) (BinaryTree.Node value lft rgt) = BinaryTree.Node a value (BinaryTree.del pred lft) rgt
BinaryTree.del a (Data.Bits.i pred) (BinaryTree.Node value lft rgt) = BinaryTree.Node a value lft (BinaryTree.del pred rgt)

BinaryTree.has <a: Type> (key: Data.Bits) (btree: BinaryTree a) : Data.Bool
BinaryTree.has a (Data.Bits.e) (BinaryTree.Node value lft rgt) = Data.Bool.true
BinaryTree.has a (Data.Bits.o pred) (BinaryTree.Node value lft rgt) = (BinaryTree.has pred lft) 
BinaryTree.has a (Data.Bits.i pred) (BinaryTree.Node value lft rgt) = (BinaryTree.has pred rgt)
BinaryTree.has a key                              (BinaryTree.Leaf) = Data.Bool.false

BinaryTree.filter <a: Type> (cond: a -> Data.Bool) (btree: BinaryTree a) : (BinaryTree (Data.Maybe a))
BinaryTree.filter cond BinaryTree.Leaf = BinaryTree.Leaf
BinaryTree.filter cond (BinaryTree.Node value lft rgt) = 
  Data.Bool.match (cond value) (x => _ ) (BinaryTree.Node (Data.Maybe.some value) (BinaryTree.filter cond lft) (BinaryTree.filter cond rgt)) (BinaryTree.Node Data.Maybe.none  (BinaryTree.filter cond lft) (BinaryTree.filter cond rgt))

BinaryTree.map <a: Type> <b: Type> (func: a -> b) (btree: BinaryTree a) : (BinaryTree b)
BinaryTree.map a b func BinaryTree.Leaf = BinaryTree.Leaf
BinaryTree.map a b func (BinaryTree.Node t value lft rgt) = BinaryTree.Node (func value) (BinaryTree.map func lft) (BinaryTree.map func rgt)

BinaryTree.key <a: Type> (btree: BinaryTree a) : (Data.List Data.Bits) 
BinaryTree.key a btree = BinaryTree.key.go btree Data.Bits.e (Data.List.nil Data.Bits)

BinaryTree.key.go <a: Type> (btree: BinaryTree a) (key: Data.Bits) (list: (Data.List Data.Bits)) : (Data.List Data.Bits) 
BinaryTree.key.go a BinaryTree.Leaf key list = list
BinaryTree.key.go a (BinaryTree.Node t value lft rgt) key list = BinaryTree.key.go rgt (Data.Bits.i key) (BinaryTree.key.go lft (Data.Bits.o key) (Data.List.cons key list))

BinaryTree.union.left <a: Type> (bitsmapa: BinaryTree a) (bitsmapb: BinaryTree a) : (BinaryTree a) 
BinaryTree.union.left a BinaryTree.Leaf bitsmapb = bitsmapb
BinaryTree.union.left a bitsmapa BinaryTree.Leaf = bitsmapa
BinaryTree.union.left a (BinaryTree.Node t value t.lft t.rgt) (BinaryTree.Node s s.value s.lft s.rgt) = BinaryTree.Node value (BinaryTree.union.left t.lft s.lft) (BinaryTree.union.left t.rgt s.rgt)

BinaryTree.union.right <a: Type> (bitsmapa: BinaryTree a) (bitsmapb: BinaryTree a) : (BinaryTree a) 
BinaryTree.union.right a BinaryTree.Leaf bitsmapb = bitsmapb
BinaryTree.union.right a bitsmapa BinaryTree.Leaf = bitsmapa
BinaryTree.union.right a (BinaryTree.Node t value t.lft t.rgt) (BinaryTree.Node s s.value s.lft s.rgt) = BinaryTree.Node s.value (BinaryTree.union.right t.lft s.lft) (BinaryTree.union.right t.rgt s.rgt)

BinaryTree.length <a> (btree: BinaryTree a) : Data.Nat
BinaryTree.length a BinaryTree.Leaf = 0n
BinaryTree.length a (BinaryTree.Node val lft rgt) = Data.Nat.succ (Data.Nat.add (BinaryTree.length lft) (BinaryTree.length rgt))

BinaryTree.update <a> (key: Data.Bits) (func: a -> a) (btree: BinaryTree a) : BinaryTree (Data.Maybe a)
BinaryTree.update a (Data.Bits.e) func (BinaryTree.Leaf) = BinaryTree.Leaf
BinaryTree.update a (Data.Bits.o pred) func (BinaryTree.Leaf) = BinaryTree.Node  (Data.Maybe.none) (BinaryTree.update pred func (BinaryTree.Leaf)) (BinaryTree.Leaf)
BinaryTree.update a (Data.Bits.i pred) func (BinaryTree.Leaf) = BinaryTree.Node  (Data.Maybe.none) (BinaryTree.Leaf) (BinaryTree.update pred func (BinaryTree.Leaf))
BinaryTree.update a (Data.Bits.e) func (BinaryTree.Node value lft rgt) = (BinaryTree.map (x => Data.Maybe.some x) (BinaryTree.Node (func value) lft rgt))
BinaryTree.update a (Data.Bits.o pred) func (BinaryTree.Node value lft rgt) = BinaryTree.update.lft value (BinaryTree.update pred func lft) rgt
BinaryTree.update a (Data.Bits.i pred) func (BinaryTree.Node value lft rgt) = BinaryTree.update.rgt value lft (BinaryTree.update pred func rgt)

BinaryTree.update.lft <a> (val: a) (lft: (BinaryTree (Data.Maybe a))) (rgt: BinaryTree a) : (BinaryTree (Data.Maybe a))
BinaryTree.update.lft a val lft rgt = (BinaryTree.Node (Data.Maybe.some val) lft (BinaryTree.map (x => Data.Maybe.some x) rgt))

BinaryTree.update.rgt <a> (val: a) (lft: BinaryTree a) (rgt: (BinaryTree (Data.Maybe a))) : (BinaryTree (Data.Maybe a))
BinaryTree.update.rgt a val lft rgt = (BinaryTree.Node (Data.Maybe.some val) (BinaryTree.map (x => Data.Maybe.some x) lft) rgt)

BinaryTree.got <a> (key: Data.Bits) (btree: BinaryTree a) : Data.Pair (BinaryTree a) (Data.Maybe a)
BinaryTree.got a (Data.Bits.e) (BinaryTree.Leaf) = Data.Pair.new BinaryTree.Leaf Data.Maybe.none
BinaryTree.got a (Data.Bits.o pred) (BinaryTree.Leaf) = Data.Pair.new BinaryTree.Leaf Data.Maybe.none
BinaryTree.got a (Data.Bits.i pred) (BinaryTree.Leaf) = Data.Pair.new BinaryTree.Leaf Data.Maybe.none
BinaryTree.got a (Data.Bits.e) (BinaryTree.Node value lft rgt) = Data.Pair.new (BinaryTree.Node value lft rgt) (Data.Maybe.some value)
BinaryTree.got a (Data.Bits.o pred) (BinaryTree.Node value lft rgt) = BinaryTree.got.lft value (BinaryTree.got pred lft) rgt
BinaryTree.got a (Data.Bits.i pred) (BinaryTree.Node value lft rgt) = BinaryTree.got.rgt value lft (BinaryTree.got pred rgt)

BinaryTree.got.lft <a> (val: a) (lft: Data.Pair (BinaryTree a) (Data.Maybe a)) (rgt: BinaryTree a) : Data.Pair (BinaryTree a) (Data.Maybe a)
BinaryTree.got.lft val (Data.Pair.new lft res) rgt = Data.Pair.new (BinaryTree.Node val lft rgt) res

BinaryTree.got.rgt <a> (val: a) (lft: BinaryTree a) (rgt: Data.Pair (BinaryTree a) (Data.Maybe a)) : Data.Pair (BinaryTree a) (Data.Maybe a)
BinaryTree.got.rgt val lft (Data.Pair.new rgt res) = Data.Pair.new (BinaryTree.Node val lft rgt) res

BinaryTree.sub.left <a> (btree: BinaryTree a) : BinaryTree a
BinaryTree.sub.left a (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.sub.left a (BinaryTree.Node value lft rgt) = lft

BinaryTree.sub.right <a> (btree: BinaryTree a) : BinaryTree a
BinaryTree.sub.right a (BinaryTree.Leaf) = (BinaryTree.Leaf)
BinaryTree.sub.right a (BinaryTree.Node value lft rgt) = rgt

BinaryTree.to_list <a> (btree: BinaryTree a) : Data.List a
BinaryTree.to_list a (BinaryTree.Leaf) = []
BinaryTree.to_list a (BinaryTree.Node value lft rgt) = Data.List.cons value (Data.List.concat (BinaryTree.to_list lft) (BinaryTree.to_list rgt))

Data.List.to_BinaryTree <a> (l: Data.List a) : BinaryTree a
Data.List.to_BinaryTree a l = BinaryTree.to_BinaryTree.insert 0n l

BinaryTree.to_BinaryTree.insert <a> (n: Data.Nat) (l: Data.List a) : BinaryTree a
BinaryTree.to_BinaryTree.insert a n Data.List.nil  = BinaryTree.Leaf
BinaryTree.to_BinaryTree.insert a n (Data.List.cons head tail) = BinaryTree.Node head (BinaryTree.to_BinaryTree.insert (Data.Nat.add (Data.Nat.mul 2n n) 1n) (Data.List.drop tail n)) (BinaryTree.to_BinaryTree.insert (Data.Nat.add (Data.Nat.mul 2n n) 2n) (Data.List.drop tail (Data.Nat.succ n)))

// BinaryTree.to_level <a> (n: Data.Nat) (btree: BinaryTree a) : Data.List a
// BinaryTree.to_level a n btree = BinaryTree.get_level n 0n btree

// BinaryTree.get_level <a> (n: Data.Nat) (m: Data.Nat) (btree: BinaryTree a) : Data.List a
// BinaryTree.get_level n m BinaryTree.Leaf = Data.List.nil
// BinaryTree.get_level Data.Nat.zero m (BinaryTree.Node value lft rgt) = [value]
// BinaryTree.get_level n m             (BinaryTree.Node value lft rgt) = 
// if (Data.Nat.equal n m) {
//   [value]
// } else {
//   Data.List.concat (BinaryTree.get_level n (Data.Nat.succ m) lft) (BinaryTree.get_level n (Data.Nat.succ m) rgt)
// }

// BinaryTree.getLevels <a> (btree: BinaryTree a) : Data.List (Data.List a)
// BinaryTree.getLevels a btree = BinaryTree.getLevels.aux ((BinaryTree.length btree)) btree

// BinaryTree.getLevels.aux <a> (n: Data.Nat) (btree: BinaryTree a) : Data.List (Data.List a)
// BinaryTree.getLevels.aux Data.Nat.zero btree = Data.List.nil
// BinaryTree.getLevels.aux (Data.Nat.succ n.pred) btree = Data.List.cons (BinaryTree.to_level n.pred btree) (BinaryTree.getLevels.aux n.pred btree)

// BinaryTree.getLevels.length <a> (btree: BinaryTree a) : Data.Nat
// BinaryTree.getLevels.length a btree = Data.List.length (BinaryTree.getLevels btree)

// BinaryTree.node.key <a> (btree: BinaryTree a) : (Data.Maybe a)
// BinaryTree.node.key a (BinaryTree.Leaf) = (Data.Maybe.none)
// BinaryTree.node.key a (BinaryTree.Node value lft rgt) = (Data.Maybe.some value)

BinaryTree.bstInsert (btree: BinaryTree Data.U60) (z: Data.U60) : BinaryTree Data.U60
BinaryTree.bstInsert (BinaryTree.Leaf) z = BinaryTree.Node z (BinaryTree.Leaf) (BinaryTree.Leaf)
BinaryTree.bstInsert (BinaryTree.Node t value lft rgt) z = Data.U60.if (< z value) (BinaryTree.Node value (BinaryTree.bstInsert lft z) rgt) (BinaryTree.Node value  lft (BinaryTree.bstInsert rgt z))

BinaryTree.bstMax  (btree: BinaryTree Data.U60) : (Data.Maybe Data.U60)
BinaryTree.bstMax (BinaryTree.Leaf) = (Data.Maybe.none)
BinaryTree.bstMax (BinaryTree.Node value (BinaryTree.Leaf) (BinaryTree.Leaf)) = (Data.Maybe.some value)
BinaryTree.bstMax (BinaryTree.Node value lft (BinaryTree.Leaf)) = (Data.Maybe.some value)
BinaryTree.bstMax (BinaryTree.Node value lft rgt) = BinaryTree.bstMax rgt

BinaryTree.bstMin (btree: BinaryTree Data.U60) : (Data.Maybe Data.U60)
BinaryTree.bstMin (BinaryTree.Leaf) = (Data.Maybe.none)
BinaryTree.bstMin (BinaryTree.Node value (BinaryTree.Leaf) (BinaryTree.Leaf)) = (Data.Maybe.some value)
BinaryTree.bstMin (BinaryTree.Node value (BinaryTree.Leaf) rgt) = (Data.Maybe.some value)
BinaryTree.bstMin (BinaryTree.Node value lft rgt) = BinaryTree.bstMin lft

BinaryTree.bstFromList  (l: Data.List Data.U60) : BinaryTree Data.U60
BinaryTree.bstFromList Data.List.nil = (BinaryTree.Leaf)
BinaryTree.bstFromList  lst = Data.List.foldl (BinaryTree.Leaf) (tree => elem => BinaryTree.bstInsert elem tree) lst

#partial
BinaryTree.nkey <a> (btree: BinaryTree a) : a
BinaryTree.nkey a (BinaryTree.Node value lft rgt) = value

Binary.isBST (btree: BinaryTree Data.U60) : Data.U60
Binary.isBST (BinaryTree.Leaf) = 1
Binary.isBST (BinaryTree.Node value (BinaryTree.Leaf) (BinaryTree.Leaf)) = 1
Binary.isBST (BinaryTree.Node value (BinaryTree.Leaf) rgt) = (& (< value (BinaryTree.nkey rgt)) (Binary.isBST rgt))
Binary.isBST (BinaryTree.Node value lft (BinaryTree.Leaf)) = (& (>= value (BinaryTree.nkey lft)) (Binary.isBST lft))  
Binary.isBST (BinaryTree.Node value lft rgt) = (& (& (>= value (BinaryTree.nkey lft)) (< value (BinaryTree.nkey rgt))) (& (Binary.isBST lft)  (Binary.isBST rgt)))  
  
// The bubble sort function


// Data.List.bubbleSort <a> (cmp: a -> a -> Data.Bool) (cmpl: a -> a -> Data.Bool)(l: Data.List a) : (Data.List a)
// Data.List.bubbleSort a cmp cmpl lst = 
//  let bpassed = (Data.List.bubblePass cmp lst)
//  if (Data.List.equal bpassed lst cmpl) {lst} else {Data.List.bubbleSort cmp cmpl bpassed}
          


// A single pass of Data.List.bubble sort
// Data.List.bubblePass <a> (cmp: a -> a -> Data.Bool) (l: Data.List a) : (Data.List a)
// Data.List.bubblePass a cmp Data.List.nil = [] 
// Data.List.bubblePass a cmp (Data.List.cons head Data.List.nil) = [head] // Singleton list is always trivially sorted.
// Data.List.bubblePass a cmp (Data.List.cons head (Data.List.cons tail.head tail.tail)) = 
//   if (cmp head tail.head) { // <
//     Data.List.cons tail.head (Data.List.bubblePass cmp (Data.List.cons head tail.tail))
//   }
//   else {
//   Data.List.cons head (Data.List.bubblePass cmp (Data.List.cons tail.head tail.tail))
//   }

Data.List.bubblesort <a> (cmp: a -> a -> Data.Bool) (xs: Data.List a) : Data.List a
Data.List.bubblesort a cmp Data.List.nil         = Data.List.nil
Data.List.bubblesort a cmp (Data.List.cons t x xs) = Data.List.bubblesort.insert cmp x (Data.List.bubblesort cmp xs)

Data.List.bubblesort.insert <a> (cmp: a -> a -> Data.Bool) (v: a) (xs: Data.List a)  :  Data.List a
Data.List.bubblesort.insert a cmp v Data.List.nil            = (Data.List.cons v Data.List.nil)
Data.List.bubblesort.insert a cmp v (Data.List.cons t x xs)  = (Data.List.bubblesort.godown cmp (cmp v x) v x xs)

Data.List.bubblesort.godown <a> (cmp: a -> a -> Data.Bool) (b: Data.Bool) (v: a) (x: a) (xs: Data.List a) : Data.List a
Data.List.bubblesort.godown a cmp Data.Bool.false v x xs = (Data.List.cons v (Data.List.cons x xs))
Data.List.bubblesort.godown a cmp Data.Bool.true v x xs = (Data.List.cons x (Data.List.bubblesort.insert cmp v xs))

Data.List.insertionsort <a> (cmp: a -> a -> Data.Bool) (l: Data.List a) : (Data.List a)
Data.List.insertionsort a cmp Data.List.nil = [] //Empty list is empty
Data.List.insertionsort a cmp (Data.List.cons head Data.List.nil) = [head] // Singleton list is always trivially sorted.
Data.List.insertionsort a cmp (Data.List.cons head tail) = Data.List.insertionsort.insert cmp head (Data.List.insertionsort cmp tail)

// -- Assumes that the second argument is an alread-sorted list,
// -- and inserts the first argument in the appropriate position
Data.List.insertionsort.insert <a> (cmp: a -> a -> Data.Bool) (v: a) (xs: Data.List a)  :  Data.List a
Data.List.insertionsort.insert a cmp v Data.List.nil            = (Data.List.cons v Data.List.nil)
Data.List.insertionsort.insert a cmp v (Data.List.cons t x xs)  = 
  if (cmp v x) {(Data.List.cons v (Data.List.cons x xs))} else {Data.List.cons x (Data.List.insertionsort.insert cmp v xs)}



Data.List.selectionsort <a> (cmp: a -> a -> Data.Bool) (xs: Data.List a) : Data.List a
Data.List.selectionsort a cmp Data.List.nil = Data.List.nil
Data.List.selectionsort a cmp lst = 
  let Data.Pair.new fst snd = Data.List.selectionsort.leastunsorted cmp lst
  Data.List.cons fst (Data.List.selectionsort cmp snd)
  
#partial
Data.List.selectionsort.leastunsorted <a> (cmp: a -> a -> Data.Bool) (xs: Data.List a) : Data.Pair a (Data.List a)
Data.List.selectionsort.leastunsorted a cmp (Data.List.cons head Data.List.nil) = Data.Pair.new head []
Data.List.selectionsort.leastunsorted a cmp (Data.List.cons head tail) = 
  let Data.Pair.new fst snd = Data.List.selectionsort.leastunsorted cmp tail

  if (cmp head fst) {Data.Pair.new head tail} else {Data.Pair.new fst (Data.List.cons head snd)}
//   Data.List.selectionsort.godown (cmp head fst) head fst tail snd


// Data.List.selectionsort.godown <a> (b: Data.Bool) (x: a) (y: a) (xs: Data.List a) (ys: Data.List a) : Data.Pair a (Data.List a)
// Data.List.selectionsort.godown a Data.Bool.false x y xs ys = Data.Pair.new y (Data.List.cons x ys)
// Data.List.selectionsort.godown a Data.Bool.true x y xs ys = Data.Pair.new x xs


// -- Sort the input list with the heap sort algorithm
// 54533 - 
// 54533 - 
Data.List.heapsort <a> (cmp: a -> a -> Data.Bool) (l: Data.List a) : (Data.List a)
Data.List.heapsort a cmp Data.List.nil = [] 
Data.List.heapsort a cmp (Data.List.cons head Data.List.nil) = [head] // Singleton list is always trivially sorted.
Data.List.heapsort a cmp xs = Data.List.heapsort.aux cmp (Data.List.maxheap cmp xs) []
// heapSort :: (Ord a) => [a] -> [a]
// heapSort [] = []
// heapSort [x] = [x]
// heapSort xs = heapSort' (maxHeap xs) []


Data.List.heapsort.aux <a> (cmp: a -> a -> Data.Bool) (l: Data.List a) (k: Data.List a) : (Data.List a)
Data.List.heapsort.aux cmp Data.List.nil out = out
Data.List.heapsort.aux cmp (Data.List.cons head tail) out = Data.List.heapsort.aux cmp (Maxheapify.extract cmp (Data.List.cons head tail)) (Data.List.concat out [head])
// -- Recursive helper function for heapSort
// heapSort' :: Ord a => [a] -> [a] -> [a]
// heapSort' [] out = out
// heapSort' h out = heapSort' (extract h) out ++ [head h] 

Data.List.maxheap <a> (cmp: a -> a -> Data.Bool) (l: Data.List a) : (Data.List a)
Data.List.maxheap a cmp Data.List.nil = []
Data.List.maxheap a cmp (Data.List.cons head Data.List.nil) = [head]
Data.List.maxheap a cmp xs = Data.List.maxheap.aux cmp xs (Data.Nat.half (Data.List.length xs))
// -- Construct a max heap (represented as a list) from a given input list
// maxHeap :: Ord a => [a] -> [a]
// maxHeap [] = []
// maxHeap [x] = [x]
// maxHeap xs = maxHeap' xs (div (length xs) 2)
Data.List.maxheap.aux <a>  (cmp: a -> a -> Data.Bool) (l: Data.List a) (int: Data.Nat) : (Data.List a)
Data.List.maxheap.aux a cmp xs Data.Nat.zero = Data.List.maxheapify cmp xs 0n
Data.List.maxheap.aux a cmp xs (Data.Nat.succ n) = Data.List.maxheap.aux cmp (Data.List.maxheapify cmp xs (Data.Nat.succ n)) n
// -- Recursive helper function for maxHeap
// maxHeap' :: Ord a => [a] -> Int -> [a]
// maxHeap' xs 0 = maxHeapify xs 0
// maxHeap' xs i = maxHeap' (maxHeapify xs i) (i-1)


// List.at_fin <a> (xs: Data.List a) (f: Data.Fin (Data.List.length xs)) : a
// List.at_fin  Data.List.nil f                              = Data.Empty.absurd (Data.Fin.impossible (f))
// List.at_fin (Data.List.cons xs.h xs.t) (Data.Fin.zero)    = xs.h
// List.at_fin (Data.List.cons xs.h xs.t) (Data.Fin.succ n)  = List.at_fin xs.t n

// List.set_fin <a> (xs: Data.List a) (f: Data.Fin (Data.List.length xs)) (x: a) : Data.List a
// List.set_fin Data.List.nil f x                              = Data.Empty.absurd (Data.Fin.impossible (f))  
// List.set_fin (Data.List.cons xs.h xs.t) (Data.Fin.zero) x   = Data.List.cons x xs.t
// List.set_fin (Data.List.cons xs.h xs.t) (Data.Fin.succ n) x = Data.List.cons xs.h (List.set_fin xs.t n x)

// Data.Fin.impossible (f: Data.Fin 0n) : Data.Empty

// Data.Fin.to_nat <n: Data.Nat> (fin: Data.Fin n) : Data.Nat
// Data.Fin.to_nat n (Data.Fin.zero n_)      = Data.Nat.zero
// Data.Fin.to_nat n (Data.Fin.succ n_ pred) = Data.Nat.succ (Data.Fin.to_nat pred)

// #partial
// Data.Nat.to_fin (n: Data.Nat) : Data.Fin n
// Data.Nat.to_fin (Data.Nat.succ Data.Nat.zero) = Data.Fin.zero
// Data.Nat.to_fin (Data.Nat.succ n) = Data.Fin.succ (Data.Nat.to_fin n)

// Data.List.index_fin <a> (xs: Data.List a) (n: Data.Nat) : a
// Data.List.index_fin a xs n = Data.List.index_fin.aux a xs n (Data.Nat.to_fin (Data.List.length xs))

// #partial
// Data.List.index_fin.aux <a> (xs: Data.List a) (n: Data.Nat) (fin: Data.Fin (Data.List.length xs)) : a
// Data.List.index_fin.aux a Data.List.nil n fin = Data.Empty.absurd (Data.Fin.impossible (fin)) 
// Data.List.index_fin.aux a (Data.List.cons head tail) Data.Nat.zero fin = head
// Data.List.index_fin.aux a (Data.List.cons head tail) (Data.Nat.succ n) (Data.Fin.succ fin) = Data.List.index_fin.aux tail n fin


#partial
Data.List.index_plus <a> (xs: Data.List a) (n: Data.Nat) : a
Data.List.index_plus a (Data.List.cons head tail) Data.Nat.zero = head
Data.List.index_plus a (Data.List.cons head tail) (Data.Nat.succ n) = Data.List.index_plus tail n 

Data.List.maxheapify <a> (cmp: a -> a -> Data.Bool) (l: Data.List a) (int: Data.Nat) : (Data.List a)
Data.List.maxheapify a cmp xs i = Data.List.maxheapify.and a cmp xs i (Maxheapify.hasleftchild xs i) (Maxheapify.hasrightchild xs i)

Data.List.maxheapify.and  <a> (cmp: a -> a -> Data.Bool) (l: Data.List a) (int: Data.Nat) (anda: Data.Bool) (andb: Data.Bool) : (Data.List a)
Data.List.maxheapify.and a cmp xs i Data.Bool.false Data.Bool.false = xs
Data.List.maxheapify.and a cmp xs i Data.Bool.true Data.Bool.true = 
  let idxl = (Maxheapify.leftchild i)
  let idxr = (Maxheapify.rightchild i)
  let largestchild = if (cmp (Data.List.index_plus xs idxl) (Data.List.index_plus xs idxr)) {
    idxl
  } else {
    idxr
  }
  Data.List.maxheapify.godown a cmp (cmp (Data.List.index_plus xs largestchild) (Data.List.index_plus xs i)) xs i largestchild 

Data.List.maxheapify.and a cmp xs i Data.Bool.true Data.Bool.false = 
  let idx = (Maxheapify.leftchild i)
  Data.List.maxheapify.godown a cmp (cmp (Data.List.index_plus xs idx) (Data.List.index_plus xs i)) xs i idx 

Data.List.maxheapify.and a cmp xs i Data.Bool.false Data.Bool.true = 
  let idx = (Maxheapify.rightchild i)
  Data.List.maxheapify.godown a cmp (cmp (Data.List.index_plus xs idx) (Data.List.index_plus xs i)) xs i idx 

Data.List.maxheapify.godown <a> (cmp: a -> a -> Data.Bool) (b: Data.Bool) (xs: Data.List a) (int: Data.Nat) (idx: Data.Nat) : (Data.List a)
Data.List.maxheapify.godown a cmp Data.Bool.false xs i idx = xs
Data.List.maxheapify.godown a cmp Data.Bool.true xs i idx = Data.List.maxheapify cmp (Maxheapify.swap xs idx i) idx

// // maxHeapify : Ord a => List a -> Int -> List a
// // maxHeapify xs i with (hasanychild xs i)
// // maxHeapify xs i | False = xs
// // maxHeapify xs i | True with (hasleftchild xs i && hasrightchild xs i)
// //   maxHeapify xs i | True, True =
// //     let largestchild = if xs ! (leftchild i) > xs ! (rightchild i) then leftchild i else rightchild i
// //     in if xs ! largestchild > xs ! i then maxHeapify (swap xs largestchild i) largestchild else xs
// //   maxHeapify xs i | True, False =
// //     if xs ! (leftchild i) > xs ! i then maxHeapify (swap xs (leftchild i) i) (leftchild i) else xs
// //   maxHeapify xs i | False, True =
// //     if xs ! (rightchild i) > xs ! i then maxHeapify (swap xs (rightchild i) i) (rightchild i) else xs
// // -- Given a heap and an index (i), move the element at i down the heap until it is in the right position


// // maxHeapify :: (Ord a) => [a] -> Int -> [a]
// // maxHeapify xs i | not (hasanychild xs i) = xs
// //                 | hasleftchild xs i && hasrightchild xs i = 
// //                     let largestchild = if xs !! (leftchild i) > xs !! (rightchild i) then leftchild i else rightchild i
// //                     in if xs !! largestchild > xs !! i then maxHeapify (swap xs largestchild i) largestchild else xs
// //                 | hasleftchild xs i =
// //                     if xs !! (leftchild i) > xs !! i then maxHeapify (swap xs (leftchild i) i) (leftchild i) else xs
// //                 | otherwise =
// //                     if xs !! (rightchild i) > xs !! i then maxHeapify (swap xs (rightchild i) i) (rightchild i) else xs


// // -- Remove the largest element from the heap, and then fix the heap
Maxheapify.extract <a> (cmp: a -> a -> Data.Bool) (l: Data.List a) : Data.List a
Maxheapify.extract a cmp Data.List.nil = []
Maxheapify.extract a cmp (Data.List.cons head Data.List.nil) = []

Maxheapify.extract a cmp (Data.List.cons head (Data.List.cons tail.head tail.tail)) = 
  Data.List.maxheapify cmp (Data.List.cons (Extract.last ((Data.List.cons tail.head tail.tail))) (Data.List.take (Data.List.cons tail.head tail.tail) (Data.List.length tail.tail))) 0n
  #partial
  Extract.last <a> (xs: Data.List a) : a
  Extract.last a (Data.List.cons head (Data.List.nil )) = head
  Extract.last a (Data.List.cons head tail)             = Extract.last tail
// // extract :: Ord a => [a] -> [a]
// // extract [] = []
// // extract [_] = []
// // extract xs = maxHeapify ((last xs):take (length xs - 2) (tail xs)) 0
// Data.List.zip_index <a> (bs: Data.List a) : Data.List (Data.Pair Data.Nat a)
// Data.List.zip_index a bs = Data.List.zip_index.aux 0n bs

// Data.List.zip_index.aux <a> (n: Data.Nat) (bs: Data.List a) : Data.List (Data.Pair Data.Nat a)
// Data.List.zip_index.aux a n (Data.List.cons b_ head tail) =
//   let head = Data.Pair.new n head
//   let tail = Data.List.zip_index.aux (Data.Nat.succ n) tail
//   Data.List.cons head tail
// Data.List.zip_index.aux a n bs = Data.List.nil

// Maxheapify.swap <a> (xs: Data.List a) (n: Data.Nat) (m: Data.Nat) : Data.List a
// Maxheapify.swap a xs n m = 
//   let ys = Data.List.zip_index  xs
//   let fold = Data.List.foldr (Data.Pair Data.Nat a) (Data.List (Data.Pair Data.Nat a)) [] (x => y => (
  
//     if (Data.Nat.equal (Data.Pair.fst x) n) {
//     (Data.List.cons (Data.List.index_plus ys m) y)
//   } else {
//     (if (Data.Nat.equal (Data.Pair.fst x) m) {
//       (Data.List.cons (Data.List.index_plus ys n) y)
//     } else {
//       (Data.List.cons x y)
//     })
//   }
// )) ys
//   Data.List.map (fold) (x => Data.Pair.snd x)




// Maxheapify.swap <a> (xs: Data.List a) (n: Data.Nat) (m: Data.Nat) : Data.List a
// Maxheapify.swap a xs n m = Data.List.map (Maxheapify.swap.index (Data.List.zip_index xs) n m) (x => Data.Pair.snd x)


// Maxheapify.swap.index <a> (xs: Data.List (Data.Pair Data.Nat a)) (n: Data.Nat) (m: Data.Nat) : Data.List (Data.Pair Data.Nat a)
// Maxheapify.swap.index a Data.List.nil n m = []
// Maxheapify.swap.index a (Data.List.cons (Data.Pair Data.Nat t) (Data.Pair.new fst snd) tail) n m = if (Data.Nat.equal fst n) {
//   Data.List.cons (Data.Pair.new m snd) (Maxheapify.swap.index tail n m)
// } else {
//   if (Data.Nat.equal fst m) {
//     Data.List.cons (Data.Pair.new n snd) (Maxheapify.swap.index tail n m)
//   } else {
//     Data.List.cons (Data.Pair.new fst snd) (Maxheapify.swap.index tail n m)
//   }
// }

Maxheapify.swap <a> (xs: Data.List a) (n: Data.Nat) (m: Data.Nat) : Data.List a
Maxheapify.swap a xs n m = 
 if (Data.Nat.gtn n m) {(Maxheapify.swap.index a xs (Data.List.length xs) n m)} else {(Maxheapify.swap.index a xs (Data.List.length xs) m n)  }

Maxheapify.swap.index <a> (xs: (Data.List a)) (n: Data.Nat) (m: Data.Nat) (o: Data.Nat) : Data.List a
// Maxheapify.swap.index a xs Data.Nat.zero m o = xs
// Maxheapify.swap.index a xs n m Data.Nat.zero = xs
// Maxheapify.swap.index a xs m Data.Nat.zero Data.Nat.zero = xs
Maxheapify.swap.index a Data.List.nil n m o = []
Maxheapify.swap.index a xs n m o =
  // if (Data.Bool.and (Data.Bool.or (Data.Nat.gte m n) (Data.Nat.gte o n)) (Data.Bool.or (Data.Nat.equal 0n m) ((Data.Nat.equal 0n o)))) { xs } else {  
    // if (Data.Nat.equal m o) { xs } else {
    //   if (Data.Nat.gtn o m) {
    //     let Data.Pair.new (fst = before) (snd = elem1after)  = Data.List.split_at xs m
    //     let Data.Pair.new fst snd = Data.List.split_at elem1after (Data.Nat.sub o m)
    //     Data.List.concat before (Maxheapify.swap.index.mount fst snd)
    // } else {
      let Data.Pair.new (fst = before) (snd = elem1after)  = Data.List.split_at xs o
      let Data.Pair.new fst snd = Data.List.split_at elem1after (Data.Nat.sub m o)
      Data.List.concat before (Maxheapify.swap.index.mount fst snd)
    // }
  // } 
// }

Maxheapify.swap.index.mount <a> (xs: (Data.List a)) (ys: (Data.List a)) : Data.List a
Maxheapify.swap.index.mount a (Data.List.nil) (Data.List.nil) = []
Maxheapify.swap.index.mount a fst (Data.List.nil) = fst
Maxheapify.swap.index.mount a (Data.List.nil) snd = snd
Maxheapify.swap.index.mount a (Data.List.cons head tail) (Data.List.cons head_ tail_) = 
  (Data.List.cons head_ (Data.List.concat tail (Data.List.cons head tail_)))

  // swap : List a -> Nat -> Nat -> Maybe (List a)
  // swap xs i1 i2 =
  //   let len = length xs in
  //     if i1 >= len || i2 >= len then
  //       Nothing
  //     else
  //       let before = take i1 xs
  //           middle = drop (i1 + 1) (take (i2 + 1) xs)
  //           after = drop (i2 + 1) xs
  //           elem1 = index xs i1
  //           elem2 = index xs i2
  //       in Just (before ++ [elem2] ++ middle ++ [elem1] ++ after)
  // Data.List.split_at
  
  // swap : List a -> Nat -> Nat -> Maybe (List a)
  // swap xs i1 i2 =
  //   let len = length xs in
  //     if i1 >= len || i2 >= len then
  //       Nothing
  //     else
  //       let (before, elem1 :: middle, elem2 :: after) = splitAt i1 xs in
  //         Just (before ++ elem2 :: middle ++ elem1 :: after)
  
  // swap : List a -> Int -> Int -> List a
  // swap xs i j
  //   | i < 0 || j < 0 || i >= length xs || j >= length xs = xs
  //   | otherwise = [if idx == i then xs !! j else if idx == j then xs !! i else x | (idx, x) <- zip [0..] xs]


  // Find_and_replace (to_remove: String) (to_add: String) (str: String) : String {
    // 	Find_and_replace.go to_remove to_add str "" (String.length to_remove) 
    // }
    
    // Find_and_replace.go (to_remove: String) (to_add: String) (str: String) (acum: String) (n: Data.U60) : String
// Find_and_replace.go String.nil to_add str acum n = str
// Find_and_replace.go to_remove String.nil str acum n = str
// Find_and_replace.go to_remove to_add String.nil acum n = acum
// Find_and_replace.go to_remove to_add (String.cons head tail) acum n = 
// 	let cond = String.equal to_remove (String.take n (String.cons head tail))
// 	let ver = (Find_and_replace.go to_remove to_add (String.drop n (String.cons head tail)) (String.concat acum to_add) n)
// 	let fal = (Find_and_replace.go to_remove to_add tail (String.concat acum (String.cons head String.nil)) n)
// Bool.match cond (x => String) ver fal



// -- Swap the values stored in two positions in a list
// swap :: [a] -> Int -> Int -> [a]
// swap xs i1 i2 = map snd . foldr (\x a -> 
//         if fst x == i1 then ys !! i2 : a
//         else if fst x == i2 then ys !! i1 : a
//         else x : a) [] $ ys
//     where ys = zip [0..] xs

// -- Index where the left child of the node at the given index should be located

Maxheapify.leftchild (n: Data.Nat) : Data.Nat
Maxheapify.leftchild i = (Data.Nat.succ (Data.Nat.mul 2n i))

// -- Index where the right child of the node at the given index should be located

Maxheapify.rightchild (n: Data.Nat) : Data.Nat
Maxheapify.rightchild i = (Data.Nat.succ (Data.Nat.succ (Data.Nat.mul 2n i)))

// -- Helper functions to determine which, if any, child nodes are present in the heap for the node at a given index
// hasleftchild, hasrightchild, hasanychild :: [a] -> Int -> Data.Bool

Maxheapify.hasleftchild <a> (l: Data.List a) (n: Data.Nat) :  Data.Bool
Maxheapify.hasleftchild xs i = Data.Nat.ltn (Maxheapify.leftchild i) (Data.List.length xs)

Maxheapify.hasrightchild <a> (l: Data.List a) (n: Data.Nat) :  Data.Bool
Maxheapify.hasrightchild xs i = Data.Nat.ltn (Maxheapify.rightchild i) (Data.List.length xs)

// Maxheapify.hasanychild <a> (l: Data.List a) (n: Data.Nat) :  Data.Bool
// Maxheapify.hasanychild xs i = Data.Bool.or (Maxheapify.hasleftchild xs i) (Maxheapify.hasrightchild xs i)



Matrix <a> (rows: Data.Nat) (columns: Data.Nat) : Type
Matrix a rows columns = Data.Vector (Data.Vector a columns) rows


// Matrix.mul <a> (m1: (Matrix 3n 3n)) (m2: (Matrix 3n 3n)) : (Matrix 3n 3n)
// Matrix.mul a (Data.Vector.cons t row (Data.Vector.cons u col head_ tail_) tail) m2 = ?


type Graph {
  new (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60)))
}
// (Data.Pair Data.U60 (Data.Pair Data.U60 Data.U60))
// Function to add an edge to graph

Graph.addedge (g: Graph) (p: Data.Pair Data.U60 Data.U60) : Graph
Graph.addedge (Graph.new e) p = Graph.new (Graph.updategraph e p)

Graph.updategraph (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60)))  (p: Data.Pair Data.U60 Data.U60) : (Data.List (Data.Pair Data.U60 (Data.List Data.U60)))
Graph.updategraph Data.List.nil (Data.Pair.new fst snd) = [(Data.Pair.new fst [snd])]
Graph.updategraph (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) (Data.Pair.new fst snd) = 
// if (Data.U60.to_bool (== head fst)) {
//   Data.List.cons (Data.Pair.new head (Data.List.cons snd tail)) tail.tail
// } else {
//   Data.List.cons (Data.Pair.new head tail) (Graph.updategraph tail.tail (Data.Pair.new fst snd))  
// }
  Graph.updategraph.godown (== head fst) (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) (Data.Pair.new fst snd)

Graph.updategraph.godown (cond: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60)))  (p: Data.Pair Data.U60 Data.U60) : (Data.List (Data.Pair Data.U60 (Data.List Data.U60)))
Graph.updategraph.godown n Data.List.nil p = Data.List.nil   
Graph.updategraph.godown 0 (Data.List.cons head tail) p = Data.List.cons head (Graph.updategraph tail p)   
Graph.updategraph.godown n (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) (Data.Pair.new fst snd) = Data.List.cons (Data.Pair.new head (Data.List.cons snd tail)) tail.tail   

BFS (g: Graph) (init: Data.U60) : Data.List Data.U60
BFS g init = BFS.visit g [init] []

BFS.visit (g: Graph) (init: Data.List Data.U60) (visit: Data.List Data.U60)  : Data.List Data.U60
BFS.visit g Data.List.nil visit  = Data.List.reverse visit
BFS.visit g (Data.List.cons head tail) visit = 
  BFS.visit.godown (Data.List.any visit (x => (Data.U60.to_bool (== x head)))) g (Data.List.cons head tail) visit
// let newVisited = if (Data.List.any visit (x => (Data.U60.to_bool (== x head)))) {visit} else {(Data.List.cons head visit)} // ruim
// let neighbours = (Data.List.filter (Get.adjacent head g) (x => NotElem x newVisited))
// // let newVisited = Data.List.concat newVisited neighbours
// let neighbours = (Data.List.concat tail neighbours)
// // newVisited
// // neighbours
// ((BFS.visit g neighbours newVisited))
BFS.visit.godown (cond: Data.Bool) (g: Graph) (init: Data.List Data.U60) (visit: Data.List Data.U60)  : Data.List Data.U60
BFS.visit.godown Data.Bool.true g (Data.List.cons head tail) visit = BFS.visit g tail visit
BFS.visit.godown Data.Bool.false g (Data.List.cons head tail) visit = 
let newVisited = (Data.List.cons head visit) 
let neighbours = (Data.List.filter (Get.adjacent head g) (x => NotElem x newVisited))
let neighbours = (Data.List.concat tail neighbours)
// newVisited
// neighbours
(BFS.visit g neighbours newVisited)
BFS.visit.godown b g u visit = Data.List.reverse visit
//   where
//   bfs-traverse' :
//     ∀ {n : ℕ}
//     → graph[ S n ]                         -- G: graph represented as adjacency matrix
//     → list (idx (S n)) → list (idx (S n))  -- Q: processing queue, L: search result list
//     → list (idx (S n))                     -- σ: seen list to avoid cycles
//     → list (idx (S n))

NotElem (t: Data.U60) (l: Data.List Data.U60) : Data.Bool
NotElem t Data.List.nil = Data.Bool.true
NotElem t (Data.List.cons xs.h xs.t) = if (Data.U60.to_bool (== t xs.h)) {
  Data.Bool.false
} else {
  NotElem t xs.t
}
// Data.List.has <a> (xs: Data.List a) (cond: a -> Data.Bool) : Data.Bool
// Data.List.has a (Data.List.nil t)            cond = Data.Bool.false
// Data.List.has a (Data.List.cons t head tail) cond = Data.Bool.if (cond head) Data.Bool.true (Data.List.any a tail cond)


  // bfs : Int -> Graph -> List Int
  // bfs s (MkGraph edges) = go [s] [s]
  //   where
  //     go : List Int -> List Int -> List Int
  //     go [] visited = reverse visited
  //     go (x :: xs) visited =
  //       let newNodes = filter (\n => notElem n visited) (getAdjacent x edges)
  //           newVisited = visited ++ newNodes
        // in go (xs ++ newNodes) newVisited






  // Data.List.filter <a> (xs: Data.List a) (cond: a -> Data.Bool) : Data.List a
 //  -- Function to perform BFS traversal of the graph
 //  bfs : Int -> Graph -> List Int
 //  bfs s (MkGraph edges) = bfs' [s] [] (length edges) where
 //    bfs' : List Int -> List Int -> Int -> List Int
 //    bfs' [] visited _ = reverse visited
 //    bfs' (x :: xs) visited n =
 //      let neighbours = getAdjacentVertices x edges
 //          newVisited = if x `elem` visited then visited else x :: visited
 //          newQueue = xs ++ filter (\v => v `notElem` (x :: visited)) neighbours
 //      in bfs' newQueue newVisited n


//  addEdge : (Int, Int) -> Graph -> Graph
//  addEdge (u, v) (MkGraph edges) = MkGraph ((u, v :: getAdjacentVertices u edges) :: edges)
// #partial
// Graph.addedge (g: Graph) (p: Data.Pair Data.U60 Data.U60) : Graph
// Graph.addedge (Graph.new e) (Data.Pair.new fst snd) = Graph.new ( Data.List.cons (Data.Pair.new fst (Data.List.cons snd (GetAdjacentVertices fst e))) e)
//  -- Helper function to get the adjacent vertices of a vertex

Get.adjacent (n: Data.U60) (g: Graph) : Data.List Data.U60
Get.adjacent n (Graph.new e) = Graph.adjacent.vertices n e

// #partial
Graph.adjacent.vertices (n: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60))) : Data.List Data.U60
Graph.adjacent.vertices n (Data.List.nil)  = []
Graph.adjacent.vertices n (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) = 
 if (Data.U60.to_bool (== n head)) {
  tail
 } else {
  Graph.adjacent.vertices n tail.tail
 }

// Graph.adjacent.vertices (n: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60))) : Data.List Data.U60
// Graph.adjacent.vertices n Data.List.nil  = []
// Graph.adjacent.vertices n (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail)= 
//   Graph.adjacent.vertices.godown (== head n) n (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) 
//   #partial
//   Graph.adjacent.vertices.godown (cond: Data.U60) (n: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60))) : Data.List Data.U60
//   Graph.adjacent.vertices.godown 0 n (Data.List.cons head tail) = (Graph.adjacent.vertices n tail)   
//   Graph.adjacent.vertices.godown c n (Data.List.cons (Data.Pair t (Data.List x)) ((Data.Pair.new head tail)) tail.tail) = tail   

type Graphs {
  new (vertices: Data.Nat) (edge: Data.Vector (Data.List Data.U60) vertices)
}



// -- BFS traversal of a graph

// bfsOfGraph vertices adj =
//   let bfsTraversal : List Nat -> Vect vertices Bool -> List Nat -> List Nat
//       bfsTraversal [] _ result = reverse result
//       bfsTraversal (node :: nodes) visited result =
//         let neighbours = adj ! node
//             newVisited = update visited node True
//             newNodes = nodes ++ filter (\n => not (visited ! n)) neighbours
//         in bfsTraversal newNodes newVisited (node :: result)
//   in bfsTraversal [0] (replicate vertices False) []

Data.List.update <a> (l: Data.List a) (idx: Data.Nat) (val: a) : Data.List a
Data.List.update  Data.List.nil n newVal = []
Data.List.update (Data.List.cons t head tail) Data.Nat.zero newVal = Data.List.cons newVal tail
Data.List.update (Data.List.cons t head tail) (Data.Nat.succ pred) newVal = Data.List.cons head (Data.List.update tail pred newVal)

Data.Vector.update_at <a> <n: Data.Nat> (l: Data.Vector a n) (idx: Data.Nat) (val: a) : Data.Vector a n

Data.Vector.update_at a n Data.Vector.nil idx newVal = Data.Vector.nil
Data.Vector.update_at a n (Data.Vector.cons t len head tail) Data.Nat.zero newVal = Data.Vector.cons len newVal tail
Data.Vector.update_at a n (Data.Vector.cons t len head tail) (Data.Nat.succ pred) newVal = Data.Vector.cons len head (Data.Vector.update_at a len tail pred newVal)


// -- Replicate a value n times
// replicate : {a : Type} -> Nat -> a -> List a
// replicate Z _ = []
// replicate (S n) val = val :: replicate n val
Data.Vector.repeat <a> (times: Data.Nat) (val: a) : Data.Vector a times
Data.Vector.repeat a Data.Nat.zero        val = Data.Vector.nil
Data.Vector.repeat a (Data.Nat.succ pred) val = Data.Vector.cons pred val (Data.Vector.repeat pred val)

#partial
Data.Vector.tail <a> <n: Data.Nat> (l: Data.Vector a n) : Data.Vector a (Data.Nat.pred n)
Data.Vector.tail a (Data.Nat.succ n) (Data.Vector.cons t len head tail) = tail
// Data.Vector.tail a (Data.Nat.succ n) (Data.Vector.nil) = 
Data.Vector.tail a Data.Nat.zero v = v

Data.Vector.at_else <a> <n: Data.Nat> (xs: Data.Vector a n) (idx: Data.Nat) (x: a) : a
Data.Vector.at_else a n (Data.Vector.nil t)            idx             x = x
Data.Vector.at_else a n (Data.Vector.cons t len head tail) Data.Nat.zero        x = head
Data.Vector.at_else a n (Data.Vector.cons t len head tail) (Data.Nat.succ pred) x = Data.Vector.at_else a len tail pred x

BFS.addNewNodes <n: Data.Nat> (nodes: Data.List Data.U60) (visited: (Data.Vector (Data.Bool) n)) (xs: Data.List Data.U60) : Data.List Data.U60 
BFS.addNewNodes n nodes visited Data.List.nil = nodes
BFS.addNewNodes n nodes visited (Data.List.cons t head tail) = 
if (Data.Vector.at_else visited (Data.U60.to_nat head) Data.Bool.true) {
  BFS.addNewNodes nodes visited tail
} else {
  BFS.addNewNodes n (Data.List.cons head nodes) (Data.Vector.update_at visited (Data.U60.to_nat head) Data.Bool.true) tail
} 



//       addNewNodes : List Nat -> Vect vertices Bool -> List Nat -> List Nat
//       addNewNodes nodes visited [] = nodes
//       addNewNodes nodes visited (x :: xs) =
//         if visited ! x then
//           addNewNodes nodes visited xs
//         else
//           addNewNodes (x :: nodes) (update visited x True) xs




//       addNewNodes nodes visited [] = nodes
//       addNewNodes nodes visited (x :: xs) =
//         if visited ! x then
//           addNewNodes nodes visited xs
//         else
//           addNewNodes (x :: nodes) (update visited x True) xs

// bfsOfGraph : (vertices : Nat) -> (adj : Vect vertices (List Nat)) -> List Nat
// bfsOfGraph vertices adj =
//   let bfsTraversal : List Nat -> Vect vertices Bool -> List Nat -> List Nat
//       bfsTraversal [] _ result = reverse result
//       bfsTraversal (node :: nodes) visited result =
//         let newVisited = update visited node True
//             newNodes = addNewNodes nodes visited (getAdjacentes vertices adj node)
//         in bfsTraversal newNodes newVisited (node :: result)

//       addNewNodes : List Nat -> Vect vertices Bool -> List Nat -> List Nat
//       addNewNodes nodes visited [] = nodes
//       addNewNodes nodes visited (x :: xs) =
//         if visited ! x then
//           addNewNodes nodes visited xs
//         else
//           addNewNodes (x :: nodes) (update visited x True) xs

//   in bfsTraversal (replicate vertices False) (replicate vertices False) []
// BFS.traversal g init visit = ?


BFS.of.graph (adj: Graphs) : Data.List Data.U60
BFS.of.graph (Graphs.new vertices edge) = BFS.traversal (Graphs.new vertices edge) [0] (Data.Vector.repeat vertices Data.Bool.false) []

BFS.traversal <n: Data.Nat> (g: Graphs) (nodes: Data.List Data.U60) (visited: (Data.Vector (Data.Bool) n)) (xs: Data.List Data.U60) : Data.List Data.U60 
BFS.traversal n g Data.List.nil visit result = result
BFS.traversal n g (Data.List.cons t head tail) visit result = 
let newresult = if (Data.List.any result (x => (Data.U60.to_bool (== x head)))) {result} else {(Data.List.cons head result)} 
let newvisited = Data.Vector.update_at visit (Data.U60.to_nat head) Data.Bool.true
let neighbours = (Graphs.adjacent head g)
let newnodes = BFS.addNewNodes tail visit neighbours
// let newNodes = (Data.List.concat tail newNodes)
// newVisited
// neighbours
(BFS.traversal g newnodes newvisited newresult)


Graphs.adjacent (n: Data.U60) (g: Graphs) : Data.List Data.U60
Graphs.adjacent n (Graphs.new vertices edge) = Graphs.adjacent.vertices n vertices edge

// #partial
Graphs.adjacent.vertices (n: Data.U60) (v: Data.Nat) (edge: (Data.Vector (Data.List Data.U60) v)) : Data.List Data.U60
Graphs.adjacent.vertices n v (Data.Vector.nil)  = []
Graphs.adjacent.vertices n v (Data.Vector.cons (Data.List t) len head tail) = 
  // let e0 = Prop.Equal.refl :: Prop.Equal t (Data.List Data.U60)  
 if (Data.Nat.equal (Data.U60.to_nat n) len) {
  head
 } else {
  Graphs.adjacent.vertices n len tail
 }



//  data Graph : Type where
//  MkGraph : List (Int, List (Int, Int)) -> Graph

// type DAG <a> {
//   new (edge: Data.List (Data.Pair a (Data.List (Data.Pair Data.U60 Data.U60))))
// }
// type Graph {
//   new (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60)))
// }
type DAG {
  new (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60))))
}
// -- This data structure represents a directed weighted graph
// -- using adjacency list representation
DAG.add (dag: DAG) (u: Data.U60) (v: Data.U60) (w: Data.U60)  : DAG 
DAG.add (DAG.new edge) u v w = DAG.new (DAG.updatedag edge u v w)

DAG.updatedag (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))) (u: Data.U60) (v: Data.U60) (w: Data.U60) : Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))
DAG.updatedag Data.List.nil p v w = [(Data.Pair.new p [(Data.Pair.new v w)])]
DAG.updatedag (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) u v w = 
  DAG.updatedag.godown ((== head u)) u v w (Data.List.cons ((Data.Pair.new head tail)) tail.tail)

// if (Data.U60.to_bool (== head u)) {
//   Data.List.cons (Data.Pair.new head (Data.List.cons (Data.Pair.new v w) tail)) tail.tail
// } else {
//   Data.List.cons (Data.Pair.new head tail) (DAG.updatedag tail.tail u v w)  
// }

// DAG.updatedag.godown (cond: Data.Bool) (u: Data.U60) (v: Data.U60) (w: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))) : Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))
// DAG.updatedag.godown Data.Bool.false u v w (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) = Data.List.cons (Data.Pair.new head tail) (DAG.updatedag tail.tail u v w)  
// DAG.updatedag.godown Data.Bool.true  u v w (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) = Data.List.cons (Data.Pair.new head (Data.List.cons (Data.Pair.new v w) tail)) tail.tail   
DAG.updatedag.godown (cond: Data.U60) (u: Data.U60) (v: Data.U60) (w: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))) : Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))
DAG.updatedag.godown 0 u v w (Data.List.cons head tail) = Data.List.cons head (DAG.updatedag tail u v w)  
// DAG.updatedag.godown 0 u v w (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) = ? //Data.List.cons (Data.Pair.new head tail) (DAG.updatedag tail.tail u v w)  
DAG.updatedag.godown n u v w (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) = Data.List.cons (Data.Pair.new head (Data.List.cons (Data.Pair.new v w) tail)) tail.tail   
DAG.updatedag.godown cond u v w Data.List.nil = Data.List.nil   


DAG.adjacent (n: Data.U60) (g: DAG) : Data.List (Data.Pair Data.U60 Data.U60)
DAG.adjacent n (DAG.new e) = DAG.adjacent.vertices n e

DAG.adjacent.vertices (n: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))) : Data.List (Data.Pair Data.U60 Data.U60)
DAG.adjacent.vertices n (Data.List.nil)  = []
DAG.adjacent.vertices n (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) = 
 if (Data.U60.to_bool (== n head)) {
  Data.List.reverse tail
 } else {
  DAG.adjacent.vertices n tail.tail
 }
// -- Function to add an edge with weight to the graph
// addEdge : (Int, Int, Int) -> Graph -> Graph
// addEdge (u, v, w) (MkGraph edges) = MkGraph ((u, (v, w) :: getAdjacent u edges) :: edges)
//   where
//     getAdjacent : Int -> List (Int, List (Int, Int)) -> List (Int, Int)
//     getAdjacent u [] = []
//     getAdjacent u ((x, adj) :: xs) =
//       if x == u
//         then adj
//         else getAdjacent u xs

DAG.BFS (g: DAG) (init: Data.U60) : Data.List Data.U60
DAG.BFS g init = DAG.BFS.visit g [init] []

DAG.BFS.visit (g: DAG) (init: Data.List Data.U60) (visit: Data.List Data.U60)  : Data.List Data.U60
DAG.BFS.visit g Data.List.nil visit = Data.List.reverse visit
DAG.BFS.visit g (Data.List.cons head tail) visit = 

// let newVisited = if (Data.List.any visit (x => (Data.U60.to_bool (== x head)))) {visit} else {(Data.List.cons head visit)} // ruim
// let neighbours = Data.List.map (DAG.adjacent head g) (x => (Data.Pair.fst x)) 
// let neighbours = (Data.List.filter neighbours (x => NotElem x newVisited)) 
// let neighbours = (Data.List.concat tail neighbours)
// // newVisited
// // neighbours
// (DAG.BFS.visit g neighbours newVisited)

  DAG.BFS.visit.godown (Data.List.any visit (x => (Data.U60.to_bool (== x head)))) g (Data.List.cons head tail) visit
#partial
DAG.BFS.visit.godown (cond: Data.Bool) (g: DAG) (init: Data.List Data.U60) (visit: Data.List Data.U60) : Data.List Data.U60
DAG.BFS.visit.godown b g  Data.List.nil visit = Data.List.reverse visit
DAG.BFS.visit.godown Data.Bool.true g (Data.List.cons head tail) visit = (DAG.BFS.visit g tail visit)
DAG.BFS.visit.godown Data.Bool.false g (Data.List.cons head tail) visit =
  let newVisited = (Data.List.cons head visit) 
  let neighbours = Data.List.map (DAG.adjacent head g) (x => (Data.Pair.fst x))
  let neighbours = (Data.List.filter neighbours (x => NotElem x newVisited)) 
  let neighbours = (Data.List.concat tail neighbours)
  // newVisited
  // neighbours
  (DAG.BFS.visit g neighbours newVisited)




// DAG.to_list (g: DAG) : (Data.List (Data.Pair Data.U60 Data.U60))
// DAG.to_list (DAG.new edge) = Data.List.map edge (x => (Data.Pair.new (Data.Pair.fst x) (Data.Pair.snd (Data.Pair.fst _))))


// BFS (g: Graph) (init: Data.U60) : Data.List Data.U60
// BFS g init = BFS.visit g [init] []

// BFS.visit (g: Graph) (init: Data.List Data.U60) (visit: Data.List Data.U60)  : Data.List Data.U60
// BFS.visit g Data.List.nil visit  = Data.List.reverse visit
// BFS.visit g (Data.List.cons head tail) visit = 

// // BFS.visit.godown (Data.List.any visit (x => (Data.U60.to_bool (== x head)))) g (Data.List.cons head tail) visit

// let neighbours = (Data.List.filter (Get.adjacent head g) (x => NotElem x (Data.List.cons head visit)))
// // let newVisited = Data.List.concat newVisited neighbours
// let neighbours = (Data.List.concat tail neighbours)
// // newVisited
// // neighbours
// ((BFS.visit g neighbours (Data.List.cons head visit)))


// -- Function to find the minimum distance node from the set of nodes not yet visited
DAG.mindistance (l: Data.List (Data.Pair Data.U60 Data.U60)) (visited: Data.List Data.U60) : Data.Maybe Data.U60 
DAG.mindistance Data.List.nil visited = Data.Maybe.none 
DAG.mindistance (Data.List.cons (Data.Pair t u) (Data.Pair.new fst snd) tail) visited = 
  let note = NotElem fst visited
  let rail = DAG.mindistance tail visited
  match Data.Maybe rail {
    none => Data.Maybe.some fst
    some value =>    
      let mim = DAG.lookup.distancep value tail
      if (Data.U60.to_bool (< snd mim)) {(Data.Maybe.some fst)} else {Data.Maybe.some value}
  }
  // minDistance : List (Int, Int) -> List Int -> Maybe Int
  // minDistance [] _ = Nothing
  // minDistance ((v, dist) :: xs) visited =
  //   if notElem v visited
  //     then case minDistance xs visited of
  //            Nothing => Just v
  //            Just u ->
  //              let minDist = lookupDistance u xs
  //              in if dist < minDist then Just v else Just u
  //     else minDistance xs visited

DAG.lookup.distancep (a: Data.U60) (xs: Data.List (Data.Pair Data.U60 Data.U60)) : Data.U60
DAG.lookup.distancep n Data.List.nil = 9999999 // arbitrário
DAG.lookup.distancep n (Data.List.cons (Data.Pair t u) (Data.Pair.new fst snd) tail) = 
  if (Data.U60.to_bool (== n fst)) {(snd)} else {(DAG.lookup.distancep n tail)}

  //     lookupDistance : Int -> List (Int, Int) -> Int
  //     lookupDistance _ [] = maxBound
  //     lookupDistance u ((v, d) :: xs) =
  //       if u == v
  //         then d
  //         else lookupDistance u xs

DAG.lookup.distance (a: Data.U60) (xs: Data.List Data.U60) : Data.U60
DAG.lookup.distance n Data.List.nil = 9999999 // arbitrário
DAG.lookup.distance n (Data.List.cons head tail) = 
  if (Data.U60.to_bool (== n (Data.Nat.to_u60 (Data.List.length tail)))) {(head)} else {(DAG.lookup.distance n tail)} 
  // lookupDistance : Int -> List Int -> Int
  // lookupDistance _ [] = maxBound
  // lookupDistance u (d :: ds) =
  //   if u == length ds
  //     then d
  //     else lookupDistance u ds
DAG.minimum (visited: Data.List Data.U60) : Data.Maybe Data.U60
DAG.minimum Data.List.nil = Data.Maybe.none
DAG.minimum (Data.List.cons head Data.List.nil) = Data.Maybe.some head
DAG.minimum (Data.List.cons head tail) = 
  Data.Maybe.some (DAG.minimum.min head (DAG.minimum tail))

  DAG.minimum.min (a: Data.U60) (u: Data.Maybe Data.U60) : Data.U60
  DAG.minimum.min a Data.Maybe.none = a
  DAG.minimum.min a (Data.Maybe.some value) = if (Data.U60.to_bool (< a value)) {a} else {value}

  // minimum : Ord a => List a -> Maybe a
  // minimum [] = Nothing
  // minimum [x] = Just x
  // minimum (x :: xs) = Just (min' x (fromJust (minimum xs)))
  //   where
  //     min' : Ord a => a -> a -> a
  //     min' a b = if a < b then a else b
DAG.adjacent.distances (dist: Data.List Data.U60) (visited: Data.List Data.U60) (g: DAG) : Data.List (Data.Pair Data.U60 Data.U60)
DAG.adjacent.distances dist visited (DAG.new e) = DAG.adjacent.distances.go dist visited e

DAG.adjacent.distances.go (dist: Data.List Data.U60) (visited: Data.List Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))) : Data.List (Data.Pair Data.U60 Data.U60)
DAG.adjacent.distances.go dist visited (Data.List.nil) = []
DAG.adjacent.distances.go dist visited (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) = 
  if (NotElem head visited) {
    Data.List.map (Data.List.concat tail (DAG.adjacent.distances.go dist visited tail.tail)) (x => (Data.Pair.new (Data.Pair.fst x) (+ (Data.Pair.snd x) (DAG.lookup.distance (Data.Pair.fst x) dist))))
  } else {
    DAG.adjacent.distances.go dist visited tail.tail
  }

//     getAdjacentDistances : List Int -> List (Int, List (Int, Int)) -> List (Int, Int)
//     getAdjacentDistances visited [] = []
//     getAdjacentDistances visited ((u, adj) :: xs) =
//       if elem u visited
//         then getAdjacentDistances visited xs
//         else map (\(v, w) => (v, w + lookupDistance v dist)) adj ++ getAdjacentDistances visited xs

// minDistance : List (Int, Int) -> List Int -> Maybe Int
// minDistance [] _ = Nothing
// minDistance ((v, dist) :: xs) visited =
//   if notElem v visited
//     then case minDistance xs visited of
//            Nothing => Just v
//            Just u =>
//              let (_, minDist) = minimumBy (\(_, d1) (_, d2) => compare d1 d2) [(u, dist), (v, dist)]
//              in if dist < minDist then Just v else Just u
//     else minDistance xs visited
// DAG.lookup (a: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))) :  Data.List (Data.Pair Data.U60 Data.U60)
// DAG.lookup n Data.List.nil = Data.List.nil // arbitrário
// DAG.lookup n (Data.List.cons (Data.Pair t u) (Data.Pair.new fst snd) tail) = 
//   if (Data.U60.to_bool (== n fst)) {(snd)} else {(DAG.lookup n tail)}

// lookup : Eq a => a -> List (a, b) -> Maybe b
// lookup _ [] = Nothing
// lookup x ((key, value) :: xs) =
//   if x == key
//     then Just value
//     else lookup x xs

  //     lookupDistance : Int -> List (Int, Int) -> Int
  //     lookupDistance _ [] = maxBound
  //     lookupDistance u ((v, d) :: xs) =
  //       if u == v
  //         then d
  //         else lookupDistance u xs

DAG.update.distances (init: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))) (dist: Data.List Data.U60) : Data.List Data.U60
DAG.update.distances u edge dist = 
  let adj = (DAG.lookup u edge)
  let dst = Data.List.map adj (x => (if (Data.U60.to_bool (== (Data.Pair.fst x) u)) {(Data.Pair.snd x)} else {(DAG.lookup.distance (Data.Pair.fst x) dist)}))
  dst //DAG.update.at_index u dst dist
  
// updateDistances : Int -> List (Int, List (Int, Int)) -> List Int -> List Int
// updateDistances u edges dist =
//   let adj = fromJust (lookup u edges)
//       updatedDist = map (\(v, w) => if v == u then w else lookupDistance v dist) adj

// 2 3 4 1 /// 2 -> 1 = 2 , 3 = 5 
           /// 3 -> 4 = (5+5) 10 
           /// 4 -> 1 = 2 // não mudar 

// node adj dist
//   2   1   2
//   2   3   4
//   3   4   5
//   4   1   2
//   4   1   2


//   in updateAtIndex u updatedDist dist
DAG.dijkstra (init: Data.U60) (d: DAG) : Data.List Data.U60 
DAG.dijkstra init (DAG.new edge) = DAG.dijkstra.go edge (Data.List.repeat ((Data.List.length edge)) 999999) [init]

  DAG.dijkstra.go (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60))))  (dist: Data.List Data.U60) (visited: Data.List Data.U60) : Data.List Data.U60
  DAG.dijkstra.go edge  dist visited = 
    let nin = DAG.mindistance (DAG.adjacent.distances dist visited (DAG.new edge)) visited
    match Data.Maybe nin {
      none => dist
      some value => 
        // [1,2,3]
        // let adj = (DAG.lookup value edge)
        let up = DAG.update.distances value edge dist 
        up// DAG.dijkstra.go edge up (Data.List.cons value visited)
    }
  
// dijkstra : Int -> Graph -> List Int
// dijkstra source (MkGraph edges) = go (replicate (length edges) 999999) [source]
//   where
//     go : List Int -> List Int -> List Int
//     go dist visited =
//       case minDistance (getAdjacentDistances visited edges) visited of
//         Nothing => dist
//         Just u =>
//           let updatedDist = updateDistances u (fromJust (lookup u edges)) dist
//           in go updatedDist (u :: visited)




// -- Function to perform Dijkstra's algorithm to find the shortest path from source to all other vertices
// dijkstra : Int -> Graph -> List Int
// dijkstra source (MkGraph edges) = go (replicate (length edges) 999999) [source]
//   where
//     go : List Int -> List Int -> List Int
//     go dist visited =
//       case minDistance (concatMap (\(u, adj) => map (\(v, w) => (v, w + lookupDistance u dist)) adj) edges) visited of
//         Nothing => dist
//         Just u =>
//           let updatedDist = map (\(v, w) => if v == u then w else lookupDistance v dist) (fromJust (lookup u edges))
//           in go updatedDist (u :: visited)

//     lookupDistance : Int -> List Int -> Int
//     lookupDistance v dist =
//       let index = fromJust (elemIndex v visited)
//       in indexAt index dist

// updateDistances : Int -> List (Int, List (Int, Int)) -> List Int -> List Int
// updateDistances u edges dist =
//   let adj = fromJust (lookup u edges)
//       updatedDist = map (\(v, w) => if v == u then w else lookupDistance v dist) adj
//   in updateAtIndex u updatedDist dist
DAG.update.at_index (idx: Data.U60) (l: Data.List Data.U60) (val: Data.List Data.U60) : Data.List Data.U60
DAG.update.at_index n Data.List.nil newVal = newVal
DAG.update.at_index n (Data.List.cons t head tail) newVal = DAG.update.at_index (- n 1) tail (DAG.replace.at_index n head newVal) 

DAG.replace.at_index <a> (idx: Data.U60) (x: a) (xs: Data.List a) : Data.List a
DAG.replace.at_index a idx x Data.List.nil = []
DAG.replace.at_index a 0 x (Data.List.cons head tail) = (Data.List.cons x tail)  
DAG.replace.at_index a inx x (Data.List.cons head tail) = (Data.List.cons head (DAG.replace.at_index inx x tail))
// updateAtIndex : Int -> List Int -> List Int -> List Int
// updateAtIndex _ [] dist = dist
// updateAtIndex index (x :: xs) dist =
//   updateAtIndex (index - 1) xs (replaceAtIndex index x dist)

// replaceAtIndex : Int -> a -> List a -> List a
// replaceAtIndex _ _ [] = []
// replaceAtIndex 0 newVal (x :: xs) = newVal :: xs
// replaceAtIndex index newVal (x :: xs) = x :: replaceAtIndex (index - 1) newVal xs

// -- Entry point
// main : IO ()
// main = do
//   let g = addEdge (0, 1, 4) $
//           addEdge (0, 2, 1) $
//           addEdge (1, 3, 1) $
//           addEdge (2, 1, 2) $
//           addEdge (2, 3, 5) $
//           addEdge (3, 4, 3) $
//           MkGraph []

//   let shortestPath = dijkstra 0 g
//   putStrLn $ "Shortest path from source 0 to all other vertices: " ++ show shortestPath

// Example: (Data.List.any Data.Nat [1,2,3,4,5] (Data.Nat.equal 4)) -> Data.Bool.true

// nub : Eq a => List a -> List a
// nub [] = []
// nub (x :: xs) = x :: nub (filter (\y => not (x == y)) xs)
Nub <a> (cmp: a -> a -> Data.Bool) (la: Data.List a) : Data.List a
Nub a cmp Data.List.nil = []
Nub a cmp (Data.List.cons head tail) = Data.List.cons head (Nub a cmp (Data.List.filter tail (x => Data.Bool.not (cmp head x))))

// lookup : Eq a => a -> List (a, b) -> Maybe b
// lookup _ [] = Nothing
// lookup key ((k, v) :: xs) = if key == k then Just v else lookup key xs

DAG.lookup (a: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))) :  Data.List (Data.Pair Data.U60 Data.U60)
DAG.lookup n Data.List.nil = Data.List.nil // arbitrário
DAG.lookup n (Data.List.cons (Data.Pair t u) (Data.Pair.new fst snd) tail) = 
  if (Data.U60.to_bool (== n fst)) {(snd)} else {(DAG.lookup n tail)}
// map : (a -> b) -> List a -> List b
// map _ [] = []
// map f (x :: xs) = f x :: map f xs

// concatMap : (a -> List b) -> List a -> List b
// concatMap _ [] = []
// concatMap f (x :: xs) = f x ++ concatMap f xs
ConcatMap <a> <b> (f: a -> (Data.List b )) (la: Data.List a) : Data.List b
ConcatMap a b f Data.List.nil = []
ConcatMap a b f (Data.List.cons t head tail) = Data.List.concat (f head) (ConcatMap f tail)

// filter : (a -> Bool) -> List a -> List a
// filter _ [] = []
// filter p (x :: xs) = if p x then x :: filter p xs else filter p xs

// notElem : Eq a => a -> List a -> Bool
// notElem _ [] = True
// notElem x (y :: ys) = if x == y then False else notElem x ys

// - Função auxiliar para encontrar o vértice com a menor distância
Maxbound : Data.U60
Maxbound = 999999

DAG.minimum.distance (lp: Data.List (Data.Pair Data.U60 Data.U60)) : (Data.Pair Data.U60 Data.U60)
DAG.minimum.distance Data.List.nil = Data.Pair.new 0 Maxbound
DAG.minimum.distance (Data.List.cons (Data.Pair t c) (Data.Pair.new head tail) tail.tail) = 
    let Data.Pair.new (fst = minv) (snd = mind) = DAG.minimum.distance tail.tail
    if (Data.U60.to_bool (< tail mind)) {Data.Pair.new head tail} else {Data.Pair.new minv mind}
// minimumDistance : List (Int, Int) -> (Int, Int)
// minimumDistance [] = (0, maxBound)
// minimumDistance ((v, d) :: xs) =
//   let (minV, minD) = minimumDistance xs
//   in if d < minD then (v, d) else (minV, minD)

// -- Função auxiliar para atualizar as distâncias dos vizinhos

DAG.update.distance (lpf: Data.List (Data.Pair Data.U60 Data.U60)) (lps: Data.List (Data.Pair Data.U60 Data.U60)) (i: Data.U60) : Data.List (Data.Pair Data.U60 Data.U60) 
DAG.update.distance Data.List.nil acc i = Data.List.reverse acc
DAG.update.distance (Data.List.cons (Data.Pair t c) (Data.Pair.new head tail) tail.tail) acc i = 
    let mind = if (Data.U60.to_bool (< (+ tail i) Maxbound)) {(+ tail i)} else {Maxbound}
    DAG.update.distance tail.tail ((Data.List.cons (Data.Pair.new head mind) acc)) i
// updateDistances : List (Int, Int) -> List (Int, Int) -> Int -> List (Int, Int)
// updateDistances [] acc _ = reverse acc
// updateDistances ((v, d) :: xs) acc dist =
//   let newDist = if d + dist < maxBound then d + dist else maxBound
//   in updateDistances xs ((v, newDist) :: acc) dist

// -- Algoritmo de Dijkstra
DAG.Dijkstra (dag: DAG) (i: Data.U60) : Data.List (Data.Pair Data.U60 Data.U60)
DAG.Dijkstra (DAG.new edges) start = 
    let vertices = Nub (x => y => (Data.U60.to_bool (== x y))) (ConcatMap (x => (Data.List.cons (Data.Pair.fst x) (Data.List.map (Data.Pair.snd x) ((y => Data.Pair.fst y))))) edges)
    let distances = Data.List.map vertices (x => (if (Data.U60.to_bool (== x start)) {(Data.Pair.new x 0)} else {((Data.Pair.new x Maxbound))}))
    (DAG.Dijkstra.go edges [] distances)
// dijkstra : Graph -> Int -> List (Int, Int)
// dijkstra (MkGraph edges) start =
//   let vertices = nub (concatMap (\(v, adj) => v :: map (\(v', _) => v') adj) edges)
//       distances = map (\v => if v == start then (v, 0) else (v, maxBound)) vertices
//       visited = []
//       unvisited = distances
//   in dijkstraHelper edges visited unvisited
DAG.Dijkstra.go (edge: Data.List (Data.Pair Data.U60 (Data.List (Data.Pair Data.U60 Data.U60)))) (visit: Data.List Data.U60) (dist: Data.List (Data.Pair Data.U60 Data.U60)) : Data.List (Data.Pair Data.U60 Data.U60)
DAG.Dijkstra.go edge visit Data.List.nil = []
DAG.Dijkstra.go edge visit dist = 
    let Data.Pair.new fst snd = DAG.minimum.distance dist
    let neighbors = DAG.adjacent.vertices fst edge
    let update = DAG.update.distance neighbors dist snd
    let newvisit = Data.List.cons fst visit
    let newdist = Data.List.filter update (x => NotElem (Data.Pair.fst x) newvisit)
    Data.List.cons (Data.Pair.new fst snd) (DAG.Dijkstra.go edge newvisit newdist)
//     dijkstraHelper : List (Int, List (Int, Int)) -> List Int -> List (Int, Int) -> List (Int, Int)
//     dijkstraHelper _ _ [] = []
//     dijkstraHelper edges visited unvisited =
//       let (u, minDist) = minimumDistance unvisited
//           neighbors = case lookup u edges of
//                         Just adj -> adj
//                         Nothing  -> []
//           updatedNeighbors = updateDistances neighbors unvisited minDist
//           newVisited = u :: visited
//           newUnvisited = filter (\(v, _) => notElem v newVisited) updatedNeighbors
//       in (u, minDist) :: dijkstraHelper edges newVisited newUnvisited


Main {
  // BinaryTree.key (BinaryTree.set (Data.Nat.to_bits 10n) 1 BinaryTree.Leaf)
  // Binary.isBST (Data.List.to_BinaryTree [1,2,3,4,5,6,888,85,9,10,11,12,13,14,15,16])
  // (Data.List.selectionsort (a => b => Data.U60.to_bool (<= a b)) [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20,13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20])
  // (Data.List.heapsort (a => b => Data.U60.to_bool (> a b)) [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20])
  // (Maxheapify.swap [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20] 5n 2n)
  // let Data.Pair.new (fst = before) (snd = elem1after) = Data.List.split_at [13, 2, 3, 14, 17, 4, 1, 5, 16, 12, 9, 10, 15, 8, 7, 11, 18, 19, 6, 20] 5n
  // let Data.Pair.new fst snd = Data.List.split_at before 1n
  // snd
  let g= Graph.new [] 
  let g = Graph.addedge g (Data.Pair.new 0 1)
  let g = Graph.addedge g (Data.Pair.new 0 2) 
  let g = Graph.addedge g (Data.Pair.new 1 3)
  let g = Graph.addedge g (Data.Pair.new 2 3)
  let g = Graph.addedge g (Data.Pair.new 2 1)
  let g = Graph.addedge g (Data.Pair.new 3 4) 
  // let h = Get.adjacent 2 g
  // let h = Bfs_traverse g 2
  let h = BFS g 2 
  // let h = BFS g 3
  // let h = BFS g 0
  // let h = BFS g 1
  // let g = Graphs.new 0n Data.Vector.nil 
  // let g = Graphs.new 1n (Data.Vector.cons 0n [1,2] Data.Vector.nil)
  // let g = Graphs.new 2n (Data.Vector.cons 1n [2] (Data.Vector.cons 0n [1,2] Data.Vector.nil))    2n
  let g = Graphs.new 3n (Data.Vector.cons 2n [1,2,3] (Data.Vector.cons 1n [2] (Data.Vector.cons 0n [1,2] Data.Vector.nil)))
  let v = Data.Vector.repeat 3n Data.Bool.false
  let v = Data.Vector.update_at v 0n Data.Bool.true
  // (Graphs.new (Data.Nat.succ (Data.Nat.succ (Data.Nat.succ (Data.Nat.zero)))) 
        // (Data.Vector.cons [1, 2, 3]  (Data.Nat.succ (Data.Nat.succ (Data.Nat.zero))) 
        // (Data.Vector.cons [2] (Data.Nat.succ (Data.Nat.zero))  
        // (Data.Vector.cons [1, 2] (Data.Nat.zero)  
        // (Data.Vector.nil)))))
  // let h = BFS.of.graph g

  let d = DAG.new [] 
  let d = DAG.add d 0 1 4
  let d = DAG.add d 0 2 1
  let d = DAG.add d 1 3 1
  let d = DAG.add d 4 1 1
  let d = DAG.add d 2 4 2
  let d = DAG.add d 2 1 2
  let d = DAG.add d 2 3 5
  let d = DAG.add d 3 4 3
  let e = DAG.adjacent 2 d
  let e = DAG.Dijkstra d 3
  // let e = DAG.BFS d 2 
  // let f = Data.Vector.update_at Data.Bool 1n (Data.Vector.nil) 1n Data.Bool.false
  e
  // Data.Vector.create 1n (x => Data.Nat.add 1n x)
  // let m = 2n
  // let n = 1n
  // let ys = Data.List.zip_index [1,2,3,4,5,6]
  // let fold = Data.List.foldr (Data.Pair Data.Nat Data.U60) (Data.List (Data.Pair Data.Nat Data.U60))  [] (x => y => (
  //     let Data.Pair.new fst snd = x
  //   if (Data.Nat.equal n (Data.Pair.fst x)) {
  //     (Data.List.cons (Data.List.index_plus ys m) y)
  //   } else {
  //     if (Data.Nat.equal (Data.Pair.fst x) m) {
  //       (Data.List.cons (Data.List.index_plus ys n) y)
  //     } else {
  //       (Data.List.cons x y)
  //       // [x]
  //     }
  //   }
  //   )) ys
  // let map = Data.List.map fold (x => Data.Pair.new (Data.Nat.to_u60 (Data.Pair.fst x)) (Data.Pair.snd x))
  // map
}


