
// Generates a tree of depth `n`
// (Genb 0 x) = (Leaf x)
// (Genb n x) = 
// 	let m = (- n 1); 
// 	(Both (Gen m (* x 2)) (Gen m (+ (* x 2) 1)))

// (Gen 0 x) = (Leaf)
// (Gen n x) = let m = (- n 1); (Node (Gen m (* x 2)) x (Gen m (+ (* x 2) 1)))


// (Gen 0 x) = Leaf
// (Gen n x) = 
//   let m = (- n 1);
//   (Node x (Gen m x) (Gen m (+ x 1)))


// // Parallel QuickSort
// (Sort Nil)         = (Leaf)
// (Sort (Cons x xs)) =
//   ((Part x xs) λmin λmax
//     let lft = (Sort min)
//     let rgt = (Sort max)
//     (Node lft x rgt))

//   // Partitions a list in two halves, less-than-p and greater-than-p
//   (Part p Nil)         = λt (t Nil Nil)
//   (Part p (Cons x xs)) = (Push (> x p) x (Part p xs))

//   // Pushes a value to the first or second list of a pair
//   (Push 0 x pair) = (pair λmin λmax λp (p (Cons x min) max))
//   (Push 1 x pair) = (pair λmin λmax λp (p min (Cons x max)))
  
// // Generates a random list
// (Rnd 0 s) = (Nil)
// (Rnd n s) = (Cons s (Rnd (- n 1) (% (+ (* s 1664525) 1013904223) 4294967296)))


// Sorts and sums n random numbers

// Sums a tree
// (Sum (Leaf x))   = x
// (Sum (Node a b)) = (+ (Sum a) (Sum b))

// (Sum (Leaf))         = 0
// (Sum (Node l m r)) = (+ m (+ (Sum l) (Sum r)))

(List.length []) = 0
(List.length (List.cons head tail)) = (+ 1 (List.length tail))

(List.map List.nil f) = List.nil
(List.map (List.cons head tail) f) = (List.cons (f head) (List.map tail f))

(List.concat [] ys) = ys
(List.concat (List.cons head tail) ys) = (List.cons head (List.concat tail ys))

// (Combinations lst k) = 
// 	let len = ((List.length lst));
// 	let eql = (== len k);
// 	let max = (> len k);
// 	(Combinations.dict lst k len eql)

// (Combinations.dict lst 0 len 0 ) = (Leaf [])
// (Combinations.dict (List.cons head tail) k len 0 ) = 
// 	let l = (- len 1);
// 	let e = (| (== l k) (< len k));
// 	let m = (> len k);
// 	let lft = (Combinations.dict tail k l e); 
//   let lft = (Node (Leaf [head]) lft);
// 	let rgt = (Combinations.dict tail (- k 1) l e); 
// 	(Node lft rgt)
// // (Combinations.dict (List.cons head tail) k len 0 m) = 
// // 	// let l = (- len 1);
// // 	// let e = (== l k);
// // 	// let m = (> len k);
// // 	// let lft = (Combinations.dict tail (- k 1) l e m); 
// //   // (Node (Leaf [head]) lft)
// (Combinations.dict lst k len 1) = (Leaf lst)

// (Combinations lst k) = 
// 	let len = ((List.length lst));
// 	let eql = (== len k);
// 	let max = (> len k);
// 	(Combinations.dict lst k len eql)

// // (Combinations.dict [] k len e) = Null
// (Combinations.dict lst 0 len e) = Null
// // (Combinations.dict lst k len 0 ) = Null
// (Combinations.dict (List.cons head tail) k len 0) = 
// 	let l = (- len 1);
// 	let e = (== l k);
// 	let m = (< len k);
// 	let lft = (Combinations.dict tail k l e); 
//   // let lft = (Node (Leaf [head]) lft);
// 	let mp = (MapTree (@x (List.cons head x)) lft);
// 	let rgt = (Combinations.dict tail (- k 1) l e); 
// 	(Node rgt mp)
// (Combinations.dict lst k len e) = (Leaf lst)



(Fold f [] b) = b
(Fold f (List.cons head tail) b) = (f head (Fold f tail b))

(Fold_map f l) = (Fold (@h @t (List.cons (f h) t)) l [])

(MapTree f Null) = Null
(MapTree f (Leaf xs)) = (Leaf (Fold_map f xs))
(MapTree f (Node left right)) = (Node (MapTree f left) (MapTree f right))

(Combinations lst k) = 
	let len = ((List.length lst));
	let eql = (== k len);
	let max = (> k len);
	(Combinations.dict lst k len eql max)

	(Combinations.dict lst 0 len eql max) = (Leaf [])
	(Combinations.dict (List.cons head tail) k len 0 0) = 
			let l = (- len 1);
			let e = (== k l);
			let m = (> k len);
			let lft = (Combinations.dict tail k l e m);
			let rgt = (CombinationsSubtree (List.cons head tail) k);
			(Node lft rgt)
	(Combinations.dict lst k len 0 max) = Null
	(Combinations.dict lst k len eql m) = (Leaf lst)

// import Data.Word (Word64)

// data Arr = Null | Leaf Word64 | Node Arr Arr deriving Show

// combinations :: [a] -> Int -> Arr
// combinations xs k
//     | k < 0 = Null
//     | k == 0 = Leaf 0
//     | otherwise = Node (combinations (tail xs) (k - 1)) (combinations (tail xs) k')
//     where k' = if length xs == k then k else k - 1

// (List.fold func [] b) = b
// (List.fold func (List.cons head tail) b) = (func head (List.fold func tail b))

// combinationsTree :: [Int] -> Int -> Arr
// combinationsTree xs k
//     | k <= 0 = Leaf []
//     | k > length xs = Null
//     | k == length xs = Leaf xs
//     | otherwise = Node (combinationsTree (tail xs) k') (combinationsSubtree xs k)
//     where k' = k - 1
// combinationsSubtree :: [Int] -> Int -> Arr
// combinationsSubtree _ 0 = Leaf []
// combinationsSubtree [] _ = Null
// combinationsSubtree (x:xs) k = Node (fmap (x:) (combinationsSubtree xs (k-1))) (combinationsSubtree xs k)


// import Data.Tree (Tree (..))

// combinations :: [a] -> Int -> Tree [a]
// combinations _ 0 = Node [] []
// combinations [] _ = Node [] []
// combinations (x:xs) k = Node [x] (combs xs (k-1)) `merge` combs xs k
//   where
//     merge :: Tree [a] -> Tree [a] -> Tree [a]
//     merge (Node a []) t2 = Node a [t2]
//     merge t1 (Node a []) = Node a [t1]
//     merge (Node a1 s1) (Node a2 s2) = Node (a1 ++ a2) (s1 ++ s2)

//     combs :: [a] -> Int -> Forest [a]
//     combs _ 0 = [Node [] []]
//     combs [] _ = []
//     combs (x:xs) k = [Node (x:ys) (combs xs (k-1)) `merge` combs xs k | ys <- combs xs (k-1)]




(CombinationsSubtree [] k) = Null
(CombinationsSubtree lst 0) = (Leaf [])
(CombinationsSubtree (List.cons head tail) k) = (Node (MapTree (@t (List.cons head t)) (CombinationsSubtree tail (- k 1))) (CombinationsSubtree tail (- k 1)))

(Sum Null)       = 0
(Sum (Leaf x))   = 1
(Sum (Node a b)) = (+ (Sum a) (Sum b))

(BOTH !a !b) = (Node a b)

(Main) = ((Combinations [1,2,3] 2))
// Sorts and sums n random numbers
// (Main) = (Sum (Sort (Rnd (<< 1 20) 1)))
// (Main) = (Gen 5 0)