// record Edge <t> {
//   weight: Data.U60
//   node: t
// }
// Graph <t> : Type
// Graph t = Data.List (Data.Pair t (Data.List (Edge t)))

// Graph.add <t> (g: Graph t) (p: Data.Pair t (Edge t)) : Graph t
// Graph.add t graph (Data.Pair.new c (Edge u) fst (Edge.new weight node)) = Data.List.cons (Data.Pair.new fst (Data.List.cons (Edge.new weight node) (Graph.adjacent fst graph))) graph

// Graph.updategraph (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60)))  (p: Data.Pair Data.U60 Data.U60) : (Data.List (Data.Pair Data.U60 (Data.List Data.U60)))
// Graph.updategraph Data.List.nil (Data.Pair.new fst snd) = [(Data.Pair.new fst [snd])]
// Graph.updategraph (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) (Data.Pair.new fst snd) = 
// // if (Data.U60.to_bool (== head fst)) {
// //   Data.List.cons (Data.Pair.new head (Data.List.cons snd tail)) tail.tail
// // } else {
// //   Data.List.cons (Data.Pair.new head tail) (Graph.updategraph tail.tail (Data.Pair.new fst snd))  
// // }
//   Graph.updategraph.godown (== head fst) (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) (Data.Pair.new fst snd)

// Graph.updategraph.godown (cond: Data.U60) (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60)))  (p: Data.Pair Data.U60 Data.U60) : (Data.List (Data.Pair Data.U60 (Data.List Data.U60)))
// Graph.updategraph.godown n Data.List.nil p = Data.List.nil   
// Graph.updategraph.godown 0 (Data.List.cons head tail) p = Data.List.cons head (Graph.updategraph tail p)   
// Graph.updategraph.godown n (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) (Data.Pair.new fst snd) = Data.List.cons (Data.Pair.new head (Data.List.cons snd tail)) tail.tail   


// Get.adjacent <t> (node: t) (g: Graph t) : Data.List (Edge t)
// Get.adjacent t node g = Graph.adjacent.vertices t node g

// Graph.adjacent.vertices <t> (node: t) (g: Graph t) : Data.List (Edge t)
// Graph.adjacent.vertices x node (Data.List.nil)  = []
// Graph.adjacent.vertices x node (Data.List.cons (Data.Pair t (Data.List (Edge c))) ((Data.Pair.new head tail)) tail.tail) = 
//  if (Data.U60.to_bool (== node head)) {
//   tail
//  } else {
//   Graph.adjacent.vertices node tail.tail
//  }































Node : Type {
	Data.U60
}

record Edge <t> {
  weight: Data.U60
  node: t
}

Edge.node <t> (e: Edge t) : t 
Edge.node t (Edge.new weight node) = node

Edge.weight <t> (e: Edge t) : Data.U60 
Edge.weight t (Edge.new weight node) = weight

Graph <t> : Type {
	Data.List (Data.Pair t (Data.List (Edge t)))
}
// Graph <t> : Type
// Graph t = Data.List (Data.Pair t (Data.List (Edge t)))

Graph.add (g: Graph Node) (p: Data.Pair Node (Edge Node)) : Graph Node
Graph.add graph (Data.Pair.new t (Edge u) fst (Edge.new weight node)) = Data.List.cons (Data.Pair.new fst (Data.List.cons (Edge.new weight node) (Graph.adjacent graph fst ))) graph

// Graph.adjacent (g: Graph Node) (node: Node) : Data.List (Edge Node)
// Graph.adjacent  g node= Graph.adjacent.vertices  g node

Graph.adjacent (g: Graph Node) (node: Node) : Data.List (Edge Node)
Graph.adjacent (Data.List.nil)  node = []
Graph.adjacent (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new head tail)) tail.tail) node = 
if (Data.U60.to_bool (== node head)) {
	tail
} else {
	Graph.adjacent tail.tail  node 
}
 
Graph.bfs (g: Graph Node) (init: Node) : Data.List Node
Graph.bfs g init = Graph.bfs.visit g [init] []

Graph.bfs.visit (g: Graph Node) (init: Data.List Node) (visit: Data.List Node)  : Data.List Node
Graph.bfs.visit g Data.List.nil visit  = Data.List.reverse visit
Graph.bfs.visit g (Data.List.cons head tail) visit = 
  Graph.bfs.visit.godown (Data.List.any visit (x => (Data.U60.to_bool (== x head)))) g (Data.List.cons head tail) visit

Graph.bfs.visit.godown (cond: Data.Bool) (g: Graph Node) (init: Data.List Node) (visit: Data.List Node)  : Data.List Node
Graph.bfs.visit.godown Data.Bool.true g (Data.List.cons head tail) visit = Graph.bfs.visit g tail visit
Graph.bfs.visit.godown Data.Bool.false g (Data.List.cons head tail) visit = 
	let newVisited = (Data.List.cons head visit) 
	let neighbours = Data.List.map (Graph.adjacent g head) (x => (Edge.node x))
	let neighbours = (Data.List.concat tail neighbours)
	(Graph.bfs.visit g neighbours newVisited)
Graph.bfs.visit.godown b g u visit = Data.List.reverse visit


NotElem (t: Data.U60) (l: Data.List Data.U60) : Data.Bool
NotElem t Data.List.nil = Data.Bool.true
NotElem t (Data.List.cons xs.h xs.t) = if (Data.U60.to_bool (== t xs.h)) {
  Data.Bool.false
} else {
  NotElem t xs.t
}

Maxbound : Data.U60
Maxbound = 999999

// Função auxiliar para encontrar o vértice com a menor distância
Graph.minimum.distance (lp: Data.List (Data.Pair Data.U60 Data.U60)) : (Data.Pair Data.U60 Data.U60)
Graph.minimum.distance Data.List.nil = Data.Pair.new 0 Maxbound
Graph.minimum.distance (Data.List.cons (Data.Pair t c) (Data.Pair.new head tail) tail.tail) = 
    let Data.Pair.new (fst = minv) (snd = mind) = Graph.minimum.distance tail.tail
    if (Data.U60.to_bool (< tail mind)) {Data.Pair.new head tail} else {Data.Pair.new minv mind}

// Função auxiliar para atualizar as distâncias dos vizinhos
Graph.update.distance (lpf: Data.List (Edge Node)) (lps: Data.List (Data.Pair Data.U60 Data.U60)) (i: Data.U60) : Data.List (Data.Pair Data.U60 Data.U60) 
Graph.update.distance Data.List.nil acc i = Data.List.reverse acc
Graph.update.distance (Data.List.cons (Edge t) (Edge.new head tail) tail.tail) acc i = 
    let mind = if (Data.U60.to_bool (< (+ head i) Maxbound)) {(+ head i)} else {Maxbound}
    Graph.update.distance tail.tail ((Data.List.cons (Data.Pair.new tail mind) acc)) i

// Algoritmo de Dijkstra
Graph.Dijkstra (g: Graph Node) (node: Node) : Data.List (Data.Pair Data.U60 Data.U60)
Graph.Dijkstra edges start = 
    let vertices = Graph.bfs edges start 
    let distances = Data.List.map vertices (x => (if (Data.U60.to_bool (== x start)) {(Data.Pair.new x 0)} else {((Data.Pair.new x Maxbound))}))
    (Graph.Dijkstra.go edges [] distances)

Graph.Dijkstra.go (edge: Graph) (visit: Data.List Data.U60) (dist: Data.List (Data.Pair Data.U60 Data.U60)) : Data.List (Data.Pair Data.U60 Data.U60)
Graph.Dijkstra.go edge visit Data.List.nil = []
Graph.Dijkstra.go edge visit dist = 
    let Data.Pair.new fst snd = Graph.minimum.distance dist
    let neighbors = Graph.adjacent edge fst
    let update = Graph.update.distance neighbors dist snd
    let newvisit = Data.List.cons fst visit
		// let notelem =  Data.List.any visit (x => (Data.U60.to_bool (== (Data.Pair.fst head) x)))
    let newdist = Data.List.filter update (x => NotElem (Data.Pair.fst x) newvisit)
    Data.List.cons (Data.Pair.new fst snd) (Graph.Dijkstra.go edge newvisit newdist)

Main {
	let g = []
	let g = Graph.add g (Data.Pair.new 4 (Edge.new 1 5))
	let g = Graph.add g (Data.Pair.new 5 (Edge.new 1 6))
	let g = Graph.add g (Data.Pair.new 6 (Edge.new 1 4))
	let g = Graph.add g (Data.Pair.new 5 (Edge.new 1 4))
	let g = Graph.add g (Data.Pair.new 4 (Edge.new 1 6))
	let g = Graph.add g (Data.Pair.new 3 (Edge.new 1 6))
	let g = Graph.add g (Data.Pair.new 1 (Edge.new 1 2))
	let g = Graph.add g (Data.Pair.new 2 (Edge.new 1 2))
	let graph = [(Data.Pair.new 0 [(Edge.new 1 0)]),(Data.Pair.new 2 [(Edge.new 1 2)]), (Data.Pair.new 1 [(Edge.new 1 2)]), (Data.Pair.new 3 [(Edge.new 1 6)]), (Data.Pair.new 4 [(Edge.new 1 6), (Edge.new 1 5)]), (Data.Pair.new 5 [(Edge.new 1 4), (Edge.new 1 6)]), (Data.Pair.new 6 [(Edge.new 1 4)])]
	let edges = g
	let start = 3 
	// 3
	let h = Graph.bfs graph start 
	// [3, 6, 4, 5]
	let distances = Data.List.map h (x => (if (Data.U60.to_bool (== x start)) {(Data.Pair.new x 0)} else {((Data.Pair.new x Maxbound))}))
	// [(Data.Pair.new 3 0), (Data.Pair.new 6 999999), (Data.Pair.new 4 999999), (Data.Pair.new 5 999999)]
	let visit = [5, 4, 6, 3] 
	// []

	///////////////////////////loop///////////////////////
	let distances = []

	let Data.Pair.new fst snd = Graph.minimum.distance distances
	// (Data.Pair.new 3 0)
	// (Data.Pair.new 6 1)
	// (Data.Pair.new 4 2)
	// (Data.Pair.new 5 3)

  let neighbors = Graph.adjacent graph fst
	// [(Edge.new 1 6)]
	// [(Edge.new 1 4)]
	// [(Edge.new 1 6), (Edge.new 1 5)]
	// [(Edge.new 1 4), (Edge.new 1 6)]

  let update = Graph.update.distance neighbors distances snd
	// [(Data.Pair.new 5 999999), (Data.Pair.new 4 999999), (Data.Pair.new 6 999999), (Data.Pair.new 3 0), (Data.Pair.new 6 1)]
	// [(Data.Pair.new 6 1), (Data.Pair.new 6 999999), (Data.Pair.new 4 999999), (Data.Pair.new 5 999999), (Data.Pair.new 4 2)]
	// [(Data.Pair.new 4 2), (Data.Pair.new 5 999999), (Data.Pair.new 4 999999), (Data.Pair.new 6 3), (Data.Pair.new 5 3)]
	// [(Data.Pair.new 5 3), (Data.Pair.new 5 999999), (Data.Pair.new 4 4), (Data.Pair.new 6 4)]

	

	let newvisit = Data.List.cons fst visit
	// [3]
	// [6, 3]
	// [4, 6, 3]
	// [5, 4, 6, 3]
	

	// let notelem =  Data.List.any visit (x => (Data.U60.to_bool (== (Data.Pair.fst x) head)))
	let newdist = Data.List.filter update (x => NotElem (Data.Pair.fst x) newvisit)
	// [(Data.Pair.new 5 999999), (Data.Pair.new 4 999999), (Data.Pair.new 6 999999), (Data.Pair.new 6 1)]
	// [(Data.Pair.new 4 999999), (Data.Pair.new 5 999999), (Data.Pair.new 4 2)]
	// [(Data.Pair.new 5 999999), (Data.Pair.new 5 3)]
	// []

	let salve =  Data.List.cons (Data.Pair.new fst snd) []
	// [(Data.Pair.new 3 0)]
	// [(Data.Pair.new 6 1)]
	// [(Data.Pair.new 4 2)]
	// [(Data.Pair.new 5 3)]
	Graph.Dijkstra edges start
}