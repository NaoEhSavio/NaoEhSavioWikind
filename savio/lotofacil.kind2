List.fold <x> <y> (func: x -> y -> y) (l: List x) (b: y) : y
List.fold func List.nil  b = b
List.fold func (List.cons l head tail) b = (func head) (List.fold func tail b)

List.length <a> (xs: List a) : U60
List.length a (List.nil t)            = 0
List.length a (List.cons t head tail) = (+ (List.length a tail) 1)

List.delete_all (v: U60) (s: List U60) : List U60
List.delete_all v (List.nil) = List.nil 
List.delete_all v (List.cons  head tail) = if (U60.equal v head) {(List.delete_all v tail)} else {(List.cons U60 head (List.delete_all v tail))}

List.filter <a> (xs: List a) (cond: a -> Bool) : List a
List.filter a (List.nil t)            cond = List.nil
List.filter a (List.cons t head tail) cond =
  if cond head {
    List.cons head (List.filter tail cond)
  } else {
    List.filter tail cond
  }

List.concat <a> (xs: List a) (ys: List a) : List a
List.concat a (List.nil t)            ys = ys
List.concat a (List.cons t head tail) ys = (List.cons a head (List.concat a tail ys))

U60.to_bool (n: U60) : Bool
U60.to_bool 0 = Bool.false
U60.to_bool n = Bool.true

List.u60.filter.go (cond: U60 -> U60) (eql: U60)  (xs: List U60)  : List U60
List.u60.filter.go cond eql (List.nil t)         = List.nil
List.u60.filter.go cond 0 (List.cons t head tail) = (List.u60.filter cond tail)
List.u60.filter.go cond 1 (List.cons t head tail) = (List.cons head (List.u60.filter cond tail))

List.u60.filter (cond: U60 -> U60) (xs: List U60)  : List U60
List.u60.filter cond (List.nil t)         = List.nil
List.u60.filter cond (List.cons t head tail) =
	let eql = (cond head)
	List.u60.filter.go cond eql (List.cons t head tail)

// Quick sort : List -> List
Quick.sort (xs: List U60) : List U60
Quick.sort List.nil = List.nil
Quick.sort (List.cons x xs) =
  let min = Quick.sort (List.u60.filter (n => (< n x)) xs)
  let max = Quick.sort (List.u60.filter (n => (> n x)) xs)
  (List.concat min (List.cons x max))


// Bubble sort : List -> List
Bubble.sort (xs: List U60) : List U60
Bubble.sort List.nil         = List.nil
Bubble.sort (List.cons t x xs) = (Insert x (Bubble.sort xs))

// Insert : U60 -> List -> List
Insert (v: U60) (xs: List U60)  :  List U60
Insert v List.nil            = (List.cons v List.nil)
Insert v (List.cons t x xs)  = (GoDown (> v x) v x xs)

// GoDown : U60 -> U60 -> U60 -> List -> List
#partial
GoDown (b: U60) (v: U60) (x: U60) (xs: List U60) : List U60
GoDown 0 v x xs = (List.cons v (List.cons x xs))
GoDown 1 v x xs = (List.cons x (Insert v xs))

Loto.soma (xs: List U60) : U60 {
	List.fold (a => b => (+ a b)) xs 0
	}
Loto (xs: List (List U60)) : List U60
Loto (List.nil) = List.nil
Loto (List.cons xs head tail) = 
	let h = Loto.soma head 
	let t = Loto tail
	List.cons h t

Porcent (xs: List U60) : List (List U60)  {
	Porcent.go xs (List.length xs)
}
Porcent.go (xs: List U60) (len: U60) : List (List U60) 
Porcent.go (List.nil xs) len = List.nil
Porcent.go (List.cons xs head tail) len = 
	let eql = (List.length (List.filter (List.cons xs head tail) (a => (U60.equal head a))))
	let por = (/ (* 1000000000 eql) len)
	let par = List.cons head (List.cons eql [por])
	let del = List.delete_all head (List.cons xs head tail)
	let res = Porcent.go del len
	List.cons par res

U60.interval (start: U60) (stop: U60) (step: U60) : List U60{
	U60.if (>= start stop) (List.nil U60) (
		List.cons (+ start step) (U60.interval (+ start step) stop step)
	)
}
U60.fac (n: U60) : U60
U60.fac 0 = 1
U60.fac n = (* n (U60.fac (- n 1)))

U60.if <r: Type> (n: U60) (t: r) (f: r) : r
U60.if r 0 t f = f
U60.if r n t f = t

#partial
U60.combination (n: U60) (p: U60) : U60
U60.combination n 0 = 1
U60.combination n 1 = n
U60.combination n p = 
let aux = U60.if (> (- n p) p) (- n p) p
U60.if (>= n p) (/ (List.fold (a => b => (* a b)) (U60.interval aux n 1) 1) (U60.fac (- n aux))) (0)


Comb (c: U60) (r: U60) : List (List U60) {
	Comb.go (U60.combination c r) r 1 (- c 1) 0 []
}
Comb.go (c: U60) (r: U60) (start: U60) (end: U60) (idx: U60) (acum: List U60) : List (List U60) 
Comb.go 0 r start end idx acum = [acum]
Comb.go c r start end idx acum = 
	U60.if (& (<=start end) (>= (- end (+ start 1)) (- r idx))) (Comb.go c r (+ start 1) end (+ idx 1) (List.concat acum [idx]))  (List.cons acum (Comb.go (- c 1) r start end  (+ 1 idx) acum))



Loto.list_result : List (List U60) {
  do List {
    ask a = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask b = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask c = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask d = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask e = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask f = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask g = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask h = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask i = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask j = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask k = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask l = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask m = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask n = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    ask o = [ 1,  2,  3, 4, 5, 6, 7, 8, 9 , 10 , 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
    return [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o]
  }
}


Main {
	let a = Loto.list_result
	let b = Loto a
	let c = Quick.sort b
 	let d = Porcent c 
	let e = U60.combination 3 2
	let f = List.length Loto.list_result
	let g = List.length (Comb 5 2)
  g
}