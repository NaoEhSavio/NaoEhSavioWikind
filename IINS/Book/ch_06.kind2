// plus_2_2_is_4 : 2 + 2 = 4
// plus_2_2_is_4 = Refl

Plus_2_2_is_4 : Prop.Equal Data.Nat (Data.Nat.add 2n 2n) 4n
Plus_2_2_is_4 = Prop.Equal.refl

// But propositions can be used in many other ways. For example, we can give a name
// to a proposition as a value on its own, just as we have given names to expressions
// of other sorts (you‚Äôll soon see why we start the name with a capital letter).

// Plus_fact : Type
// Plus_fact = 2+2=4
Plus_fact : Type
Plus_fact = Prop.Equal Data.Nat (Data.Nat.add 2n 2n) 4n

// ŒªŒ†> :t Plus_fact
// Plus_fact : Type

// We can later use this name in any situation where a proposition is expected ‚Äì for
// example, in a function declaration.

Plus_fact_is_true : Plus_fact
Plus_fact_is_true = Prop.Equal.refl

// (Here‚Äôs the reason - recall that names starting with lowercase letters are considered
// implicits in Idris, so plus_fact would be considered a free variable!)
// We can also write parameterized propositions ‚Äì that is, functions that take arguments of some type and return a proposition. For instance, the following function
// takes a number and returns a proposition asserting that this number is equal to
// three:
Is_three (n: Data.Nat) : Type
Is_three n = Prop.Equal Data.Nat n 3n

// is_three : Data.Nat ‡±è> Type
// is_three n = n=3
// ŒªŒ†> :t is_three
// is_three : Data.Nat ‡±è> Type

// In Idris, functions that return propositions are said to define properties of their
// arguments.

// For instance, here‚Äôs a (polymorphic) property defining the familiar notion of an
// injective function.

Injective <a> <b> (f: a -> b) : Type
Injective a b f = (x: a) -> (y: a) -> (e: Prop.Equal b (f x) (f y)) -> (Prop.Equal a x y)

// Injective : (f : a ‡±è> b) ‡±è> Type
// Injective {a} {b} f = (x, y : a) ‡±è> f x = f y ‡±è> x = y

Succ_inj : Injective ((x: Data.Nat) => Data.Nat.succ x)
Succ_inj = (n: Data.Nat) => (m: Data.Nat) => (e : Prop.Equal Data.Nat (Data.Nat.succ n) (Data.Nat.succ m)) => (
 	let p = Prop.Equal.apply (x => Data.Nat.pred x) e
 	p
 	)

// succ_inj : Injective S
// succ_inj x x Refl = Refl

// The equality operator = is also a function that returns a Type.
// The expression n = m is syntactic sugar for (=) n m, defined internally in Idris. Because = can be used with elements of any type, it is also polymorphic:


// ŒªŒ†> :t (=)
// (=) : A ‡±è> B ‡±è> Type

// 1. Logical Connectives

// 1.1. Conjunction. The conjunction (or logical and) of propositions a and b

// in Idris is the same as the pair of a and b, written (a, b), representing the claim

// that both a and b are true.

// and_example : (3 + 4 = 7, 2 * 2 = 4)
And_example : Data.Pair (Prop.Equal Data.Nat (Data.Nat.add 3n 4n) 7n) (Prop.Equal Data.Nat (Data.Nat.mul 2n 2n) 4n)
// To prove a conjunction, we can use value-level pair syntax:
// and_example = (Refl, Refl)
And_example = Data.Pair.new (Prop.Equal.refl) (Prop.Equal.refl)

// For any propositions a and b, if we assume that a is true and we assume that b is
// true, we can trivially conclude that (a,b) is also true.

And_intro <a> <b>: a -> b -> (Data.Pair a b)
And_intro a b = x => y => Data.Pair.new x y

// and_intro : a ‡±è> b ‡±è> (a, b)
// and_intro = MkPair

// 1.1.1. Exercise: 2 stars (and_exercise).

And_exercise (n: Data.Nat) (m: Data.Nat) (e: Prop.Equal Data.Nat (Data.Nat.add n m) 0n) : Data.Pair (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n)
// And_exercise n m e = ?and_exercise

// and_exercise : (n, m : Data.Nat) ‡±è> n + m = 0 ‡±è> (n = 0, m = 0)
// and_exercise n m prf = ?and_exercise_rhs

// So much for proving conjunctive statements. To go in the other direction ‚Äì i.e.,
// to use a conjunctive hypothesis to help prove something else ‚Äì we employ pattern
// matching.
// If the proof context contains a hypothesis h of the form (a,b), case splitting will
// replace it with a pair pattern (a,b).

And_example2 (n: Data.Nat) (m: Data.Nat) (e: Data.Pair (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n)) : Prop.Equal Data.Nat (Data.Nat.add m n) 0n
And_example2 Data.Nat.zero Data.Nat.zero e = Prop.Equal.refl
And_example2 (Data.Nat.succ n.pred) Data.Nat.zero e = 
		let p = (Prop.Equal.rewrite 
			(Data.Pair.fst e) 
			(x => match Data.Nat x {
				zero => Data.Empty
				succ => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
		Data.Empty.absurd p
And_example2 Data.Nat.zero (Data.Nat.succ m.pred) e = 
		let p = (Prop.Equal.rewrite 
			(Data.Pair.snd e) 
			(x => match Data.Nat x {
				zero => Data.Empty
				succ => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
		Data.Empty.absurd p

And_example2 (Data.Nat.succ n.pred) (Data.Nat.succ m.pred) e = 
		let p = (Prop.Equal.rewrite 
			(Data.Pair.fst e) 
			(x => match Data.Nat x {
				zero => Data.Empty
				succ => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
		Data.Empty.absurd p

// and_example2 : (n, m : Data.Nat) ‡±è> (n = 0, m = 0) ‡±è> n + m = 0
// and_example2 Z Z (Refl,Refl) = Refl
// and_example2 (S _) _ (Refl,_) impossible
// and_example2 _ (S _) (_,Refl) impossible
// You may wonder why we bothered packing the two hypotheses n = 0 and m = 0 into
// a single conjunction, since we could have also stated the theorem with two separate
// premises:

And_example3 (n: Data.Nat) (m: Data.Nat) (e: (Prop.Equal Data.Nat n 0n)) (p: (Prop.Equal Data.Nat m 0n)) : Prop.Equal Data.Nat (Data.Nat.add n m) 0n
// And_example3 n m e p = ?

// and_example2' : (n, m : Data.Nat) ‡±è> n = 0 ‡±è> m = 0 ‡±è> n + m = 0
// and_example2' Z Z Refl Refl = Refl
// and_example2' (S _) _ Refl _ impossible
// and_example2' _ (S _) _ Refl impossible
// For this theorem, both formulations are fine. But it‚Äôs important to understand
// how to work with conjunctive hypotheses because conjunctions often arise from
// intermediate steps in proofs, especially in bigger developments. Here‚Äôs a simple
// example:

And_example4 (n: Data.Nat) (m: Data.Nat) (e: Prop.Equal Data.Nat (Data.Nat.add n m) 0n) : (Prop.Equal Data.Nat (Data.Nat.mul n m) 0n)
And_example4 n m e = 
	let fst = Data.Pair.fst (And_exercise n m e)
	let app = Prop.Equal.apply (x => Data.Nat.mul x m) fst
	app

// and_example3 : (n, m : Data.Nat) ‡±è> n + m = 0 ‡±è> n * m = 0
// and_example3 n m prf =
// let (nz, _) = and_exercise n m prf in
// rewrite nz in Refl
// Remove lemma and exercise, use fst and snd directly?
// Another common situation with conjunctions is that we know (a,b) but in some
// context we need just a (or just b). The following lemmas are useful in such cases: 

Proj1 <p> <q> : (Data.Pair p q) -> p 
Proj1 p q = (x: (Data.Pair p q)) => Data.Pair.fst x

Proj1v2 <p> <q> (pair:Data.Pair p q) : p 
Proj1v2 p q pair = Data.Pair.fst pair

Proj1v3 <p> <q> (pair:Data.Pair p q) : p 
Proj1v3 p q (Data.Pair.new fst snd) = fst

// proj1 : (p, q) ‡±è> p
// proj1 = fst

// 1.1.2. Exercise: 1 star, optional (proj2).

Proj2 <p> <q> : (Data.Pair p q) -> q
Proj2 p q = (x: (Data.Pair p q)) => Data.Pair.snd x

Proj2v2 <p> <q> (pair:Data.Pair p q) : q 
Proj2v2 p q pair = Data.Pair.snd pair

// proj2 : (p, q) ‡±è> q
// proj2 x = ?proj2_rhs

// Finally, we sometimes need to rearrange the order of conjunctions and/or the
// grouping of multi-way conjunctions. The following commutativity and associativity theorems are handy in such cases.

// and_commut : (p, q) ‡±è> (q, p)
// and_commut (p, q) = (q, p)

And_commut <p> <q> (pair: Data.Pair p q) : Data.Pair q p
And_commut (Data.Pair.new fst snd) = Data.Pair.new snd fst

// 1.1.3. Exercise: 2 stars (and_assoc). Remove or demote to 1 star?

// and_assoc : (p, (q, r)) ‡±è> ((p, q), r)
// and_assoc x = ?and_assoc_rhs

And_assoc (p) (q) (r) (pair: Data.Pair p (Data.Pair q r)) : Data.Pair (Data.Pair p q) r
And_assoc p q r (Data.Pair.new pair.p (Data.Pair pair.q pair.r) fst (Data.Pair.new snd trd)) = (Data.Pair.new (Data.Pair.new fst snd) trd) 

// 1.2. Disjunction.
// Hide Basics.Booleans analogues and make syntax synonyms (/\) and (\/) for (,)
// and Data.Either?
// Another important connective is the disjunction, or logical or of two propositions:
// a `Data.Either` b is true when either a or b is. The first case has be tagged with Left,
// and the second with Right.
// To use a disjunctive hypothesis in a proof, we proceed by case analysis, which,
// as for Data.Nat or other data types, can be done with pattern matching. Here is an
// example:

Or_example (n: Data.Nat) (m: Data.Nat) (e: (Data.Either (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n))) : Prop.Equal Data.Nat (Data.Nat.mul n m) 0n
Or_example Data.Nat.zero m (Data.Either.left l r Prop.Equal.refl) = Prop.Equal.refl
Or_example n Data.Nat.zero (Data.Either.right l r val) = Mult_0_r n
Or_example (Data.Nat.succ n.pred) m (Data.Either.left l r val) = 
	let p = (Prop.Equal.rewrite 
			val
			(x => match Data.Nat x {
				zero => Data.Empty
				succ => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
		Data.Empty.absurd p
Or_example n (Data.Nat.succ m.pred) (Data.Either.right l r val) = 
	let p = (Prop.Equal.rewrite 
			val
			(x => match Data.Nat x {
				zero => Data.Empty
				succ => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
		Data.Empty.absurd p

// or_example : (n, m : Data.Nat) ‡±è> ((n = 0) `Data.Either` (m = 0)) ‡±è> n * m = 0
// or_example Z _ (Left Refl) = Refl
// or_example (S _) _ (Left Refl) impossible
// or_example n Z (Right Refl) = multZeroRightZero n
// or_example _ (S _) (Right Refl) impossible

// Conversely, to show that a disjunction holds, we need to show that one of its sides
// does. This can be done via aforementioned Left and Right constructors. Here is a
// trivial use‚Ä¶

Or_intro_left <a> <b> (t: a) : Data.Either a b
Or_intro_left t = Data.Either.left t


Or_intro_right <a> <b> (t: b) : Data.Either a b
Or_intro_right t = Data.Either.right t

// or_intro : a ‡±è> a `Data.Either` b
// or_intro = Left

// ‚Ä¶ and a slightly more interesting example requiring both Left and Right:
Zero_or_succ (n: Data.Nat) : Data.Either (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat n (Data.Nat.succ (Data.Nat.pred n)))
Zero_or_succ Data.Nat.zero = Data.Either.left Prop.Equal.refl
Zero_or_succ (Data.Nat.succ n.pred) = Data.Either.right Prop.Equal.refl

// zero_or_succ : (n : Data.Nat) ‡±è> ((n = 0) `Data.Either` (n = S (pred n)))
// zero_or_succ Z = Left Refl
// zero_or_succ (S _) = Right Refl

// 1.2.1. Exercise: 1 star (mult_eq_0).
Mult_ep_0 (n: Data.Nat) (m: Data.Nat) (e: Prop.Equal (Data.Nat.mul n m) 0n) : Data.Either (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n)
// Mult_ep_0 n m e = ?

// mult_eq_0 : n * m = 0 ‡±è> ((n = 0) `Data.Either` (m = 0))
// mult_eq_0 prf = ?mult_eq_0_rhs
// ‚ñ°
// 1.2.2. Exercise: 1 star (or_commut).
Or_commut <p> <q> (eth: Data.Either p q) : (Data.Either q p)
// Or_commut p q eth = ?
// or_commut : (p `Data.Either` q) ‡±è> (q `Data.Either` p)
// or_commut x = ?or_commut_rhs
// ‚ñ°
// 1.3. Falsehood and Negation. So far, we have mostly been concerned with
// proving that certain things are true ‚Äì addition is commutative, appending lists is
// associative, etc. Of course, we may also be interested in negative results, showing
// that certain propositions are not true. In Idris, such negative statements are
// expressed with the negation typelevel function Not.
// Add hyperlink
// To see how negation works, recall the discussion of the principle of explosion
// from the previous chapter; it asserts that, if we assume a contradiction, then any
// other proposition can be derived. Following this intuition, we could define Not p
// as q ‡±è> (p ‡±è> q). Idris actually makes a slightly different choice, defining Not p
// as p ‡±è> Void, where Void is a particular contradictory proposition defined in the
// standard library as a data type with no constructors.
// type Data.Empty {

// }

// data Void : Type where

Not <t> : Type
Not t = t -> Data.Empty

// Not : Type ‡±è> Type
// Not a = a ‡±è> Void
// Discuss difference between void and absurd
// Since Void is a contradictory proposition, the principle of explosion also applies to
// it. If we get Void into the proof context, we can call void or absurd on it to complete
// any goal:

Ex_falso_quodlibet <t> : Data.Empty -> t
Ex_falso_quodlibet t = e => Data.Empty.absurd e

// ex_falso_quodlibet : Void ‡±è> p
// ex_falso_quodlibet = void
// The Latin ex falso quodlibet means, literally, ‚Äúfrom falsehood follows whatever you
// like‚Äù; this is another common name for the principle of explosion.

// 1.3.1. Exercise: 2 stars, optional (not_implies_our_not). Show that Idris‚Äôs
// definition of negation implies the intuitive one mentioned above:

Not_implies_our_not <p> <q> (e: Not p) : (q -> (p -> q))
// Not_implies_our_not p q e = ?

// not_implies_our_not : Not p ‡±è> (q ‡±è> (p ‡±è> q))
// not_implies_our_not notp q p = ?not_implies_our_not_rhs
// ‚ñ°
// This is how we use Not to state that 0 and 1 are different elements of Data.Nat:
// Explain Refl-lambda syntax and Uninhabited, keep in mind
// https://github.com/idris-lang/Idris-dev/issues/3943

Zero_not_one : Not (Prop.Equal Data.Nat 0n (Data.Nat.succ _))
// Zero_not_one = ?

// zero_not_one : Not (Z = S _)
// zero_not_one = \Refl impossible
// We could also rely on the Uninhabited instance in stdlib and write this as
// zero_not_one = uninhabited
// It takes a little practice to get used to working with negation in Idris. Even though
// you can see perfectly well why a statement involving negation is true, it can be
// a little tricky at first to get things into the right configuration so that Idris can
// understand it! Here are proofs of a few familiar facts to get you warmed up.
Not_False : Not Data.Empty
Not_False = e => Data.Empty.absurd e

// not_False : Not Void
// not_False = absurd

Contradiction_implies_anything <p> <q> (pair: Data.Pair p (Not p)) : q
Contradiction_implies_anything p q (Data.Pair.new fst snd) = Data.Empty.absurd (snd fst)


// contradiction_implies_anything : (p, Not p) ‡±è> q
// contradiction_implies_anything (p, notp) = absurd $ notp p

Double_neg <p> : Not (Not p)
// Double_neg p = Data.Empty.absurd 

// double_neg : p ‡±è> Not $ Not p
// double_neg p notp = notp p
// 1.3.2. Exercise: 2 stars, advanced, recommended (double_neg_inf). Write an
// informal proof of double_neg:
// Theorem: p implies Not $ Not p, for any proposition p.
// -- FILL IN HERE

// 1.3.3. Exercise: 2 stars, recommended (contrapositive).
Contrapositive <p> <q> (f: p -> q) : (Not q -> Not p)
// Contrapositive p q f = ?

// contrapositive pq = ?contrapositive_rhs

// 1.3.4. Exercise: 1 star (not_both_true_and_false).
Not_both_true_and_false <p> : Not (Data.Pair p (Not p))
// Not_both_true_and_false p = ?

// not_both_true_and_false : Not (p, Not p)
// not_both_true_and_false = ?not_both_true_and_false_rhs
// ‚ñ°
// 1.3.5. Exercise: 1 star, advanced (informal_not_PNP). Write an informal
// proof (in English) of the proposition Not (p, Not p).
// -- FILL IN HERE

// Similarly, since inequality involves a negation, it requires a little practice to be
// able to work with it fluently. Here is one useful trick. If you are trying to prove a
// goal that is nonsensical (e.g., the goal state is False = True), apply absurd to change
// the goal to Void. This makes it easier to use assumptions of the form Not p that
// may be available in the context ‚Äì in particular, assumptions of the form Not (x=y).

Not_true_is_false (b: Data.Bool) (e: Not (Prop.Equal Data.Bool b Data.Bool.true)) : Prop.Equal Data.Bool b Data.Bool.false
Not_true_is_false Data.Bool.false e = Prop.Equal.refl
Not_true_is_false Data.Bool.true e = Data.Empty.absurd (e Prop.Equal.refl)

// not_true_is_false False h = Refl
// not_true_is_false True h = absurd  h Refl
// 1.4. Truth. Besides Void, Idris‚Äôs standard library also defines Data.Unit, a proposition that is trivially true. To prove it, we use the predefined constant ():
True_is_true : Data.Unit
True_is_true = Data.Unit.new

// True_is_true : Data.Unit
// True_is_true = ()

// Unlike Void, which is used extensively, Data.Unit is used quite rarely in proofs, since it
// is trivial (and therefore uninteresting) to prove as a goal, and it carries no useful
// information as a hypothesis. But it can be quite useful when defining complex
// proofs using conditionals or as a parameter to higher-order proofs. We will see
// examples of such uses of Data.Unit later on.

// 1.5. Logical Iff. The handy ‚Äúif and only if‚Äù connective, which
// asserts that two propositions have the same truth value, is just the conjunction of
// two implications.

// namespace MyIff
// iff : {p,q : Type} ‡±è> Type
// iff {p} {q} = (p ‡±è> q, q ‡±è> p)
Iff <p> <q> : Type
Iff p q = Data.Pair (p -> q) (q -> p)

// Iff (p: Type) (q: Type) : Type
// Data.Pair.new <p: Type> <q: Type> (lft: (_: p) q) (rgt: (_: q) p) : (Iff p q)

// type Iff (p) (q) {
// 	new (lft: p -> q) (rgt: q -> p)
// }
// Iff.rgt <p> <q> (e: Iff p q) : (q -> p)
// // Iff.rgt (Data.Pair.new p q l r)    = l (Iff.lft (Data.Pair.new p q l r))
// Iff.lft <p> <q> (e: Iff p q) : p  
// // Iff.lft p q (Data.Pair.new pp qq l r) =  r 

Foo <p> <q> (f: p -> q) : q

Iff.mirror <p> <q> (e: Iff p q) : Iff q p
Iff.mirror p q (Data.Pair.new lft rgt) = (Data.Pair.new rgt lft)



// Idris‚Äôs stdlib has a more general form of this, Iso, in Control.Isomorphism.
// syntax [p] ‚Äù<‡±¶>‚Äù [q] = iff {p} {q}

// Iff.swap <p> <q> (i: Iff p q) : (Iff q p)
// Iff.swap p q (Data.Pair.new fst snd ) = Data.Pair.new snd fst

// iff_sym : (p <‡±¶> q) ‡±è> (q <‡±¶> p)
// iff_sym (pq, qp) = (qp, pq)


Not_true_iff_false (b: Data.Bool) : Iff (Not (Prop.Equal Data.Bool b Data.Bool.true)) (Prop.Equal Data.Bool b Data.Bool.false)
Not_true_iff_false  b = Data.Pair.new ((x: Not (Prop.Equal Data.Bool b Data.Bool.true))  => Not_true_is_false b x) ((y: Prop.Equal Data.Bool b Data.Bool.false) => Not_true_and_false b y)

// not_true_iff_false : (Not (b = True)) <‡±¶> (b = False)
// not_true_iff_false {b} = (not_true_is_false b, not_true_and_false b)
// where

Not_true_and_false (b : Data.Bool) (e: Prop.Equal Data.Bool b Data.Bool.false) : Not (Prop.Equal Data.Bool b Data.Bool.true)
Not_true_and_false Data.Bool.false Prop.Equal.refl = 
	emp => 
	let p = (Prop.Equal.rewrite emp
			(x => match Data.Bool x {
				true => Data.Empty
				false => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
	Data.Empty.absurd p

Not_true_and_false Data.Bool.true e = 
	let p = Prop.Equal.rewrite e (x => if x {Data.Unit} else {Data.Empty}) Data.Unit.new
	Data.Empty.absurd p
// not_true_and_false : (b : Data.Bool) ‡±è> (b = False) ‡±è> Not (b = True)
// not_true_and_false False _ Refl impossible
// not_true_and_false True Refl _ impossible

// 1.5.1. Exercise: 1 star, optional (iff_properties). Using the above proof that
// <‡±¶> is symmetric (iff_sym) as a guide, prove that it is also reflexive and transitive.

Iff.refl <p> : Iff p p
Iff.refl p = (Data.Pair.new ((p: p) => p) ((p: p) => p))

// iff_refl : p <‡±¶> p
// iff_refl = ?iff_refl_rhs

Iff.chain (p) (q) (r) (e0: Iff p q) (e1: Iff q r) : Iff p r
Iff.chain p q r e0 (Iff.refl x) =  e0 :: Iff p x

// iff_trans : (p <‡±¶> q) ‡±è> (q <‡±¶> r) ‡±è> (p <‡±¶> r)
// iff_trans piq qir = ?iff_trans_rhs
// ‚ñ°
// 1.5.2. Exercise: 3 stars (or_distributes_over_and).

Or_distributes_over_and (p) (q) (r) : Iff (Data.Either p (Data.Pair q r)) (Data.Pair (Data.Either p q) (Data.Either p r))
Or_distributes_over_and p q r = Data.Pair.new ((x: Data.Either p (Data.Pair q r)) => To_Or_distributes_over_and p q r x) ((x: Data.Pair (Data.Either p q) (Data.Either p r)) => Fro_Or_distributes_over_and p q r x)

To_Or_distributes_over_and (p) (q) (r) (e: Data.Either p (Data.Pair q r)) : Data.Pair (Data.Either p q) (Data.Either p r)

Fro_Or_distributes_over_and (p) (q) (r) (e: Data.Pair (Data.Either p q) (Data.Either p r)) : Data.Either p (Data.Pair q r)

// or_distributes_over_and : (p `Data.Either` (q,r)) <‡±¶> (p `Data.Either` q, p `Data.Either` r)
// or_distributes_over_and = ?or_distributes_over_and_rhs
// ‚ñ°
// Edit the rest of the section. What to do with Setoids? We could probably just
// use profunctors here
// Some of Idris‚Äôs tactics treat iff statements specially, avoiding the need for some
// low-level proof-state manipulation. In particular, rewrite and reflexivity can be
// used with iff statements, not just equalities. To enable this behavior, we need to
// import a special Idris library that allows rewriting with other formulas besides
// equality (setoids).
// Here is a simple example demonstrating how these tactics work with iff. First,
// let‚Äôs prove a couple of basic iff Iffs‚Ä¶

Mult_0 (n: Data.Nat) (m: Data.Nat) : Iff (Prop.Equal Data.Nat (Data.Nat.mul n m) 0n) (Data.Either (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n))
// Mult_0 n m = Data.Pair.new (x => To_mult_0 n m x) (y => Or_example n m y)
// mult_0 : (n * m = Z) <‡±¶> ((n = Z) `Data.Either` (m = Z))
// mult_0 {n} {m} = (to n m, or_example n m)
// where
Plus_comm (n: Data.Nat) (m: Data.Nat) : (Prop.Equal Data.Nat (Data.Nat.add n m) (Data.Nat.add m n))

To_mult_0 (n: Data.Nat) (m: Data.Nat) (e: Prop.Equal Data.Nat (Data.Nat.mul n m) 0n) : (Data.Either (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n))
To_mult_0 Data.Nat.zero Data.Nat.zero Prop.Equal.refl = Data.Either.right Prop.Equal.refl
To_mult_0 Data.Nat.zero (Data.Nat.succ m) Prop.Equal.refl = Data.Either.left Prop.Equal.refl
To_mult_0 (Data.Nat.succ n) Data.Nat.zero e = Data.Either.right Prop.Equal.refl
To_mult_0 (Data.Nat.succ n) (Data.Nat.succ m) e =
		let a = Plus_comm (Data.Nat.mul n (Data.Nat.succ m)) (Data.Nat.succ m)
		let b = Prop.Equal.chain (Prop.Equal.mirror e) a
		let c = (Prop.Equal.rewrite b
			(x => match Data.Nat x {
				zero => Data.Unit
				succ => Data.Empty
		 	})
		 	(Data.Unit.new)) 
		Data.Empty.absurd c

// to : (n, m : Data.Nat) ‡±è> (n * m = Z) ‡±è> (n = 0) `Data.Either` (m = 0)
// to Z _ Refl = Left Refl
// to (S _) Z _ = Right Refl
// to (S _) (S _) Refl impossible
Or_assoc (p) (q) (r) : Iff (Data.Either p (Data.Either q r)) (Data.Either (Data.Either p q) r)
Or_assoc p q r = Data.Pair.new ((x: Data.Either p (Data.Either q r)) => To_or_assoc p q r x) ((y: Data.Either (Data.Either p q) r)  => Fro_or_assoc p q r y)
// or_assoc : (p `Data.Either` (q `Data.Either` r)) <‡±¶> ((p `Data.Either` q) `Data.Either` r)
// or_assoc = (to, fro)
// where
To_or_assoc (p) (q) (r) (e: Data.Either p (Data.Either q r)) : Data.Either (Data.Either p q) r
To_or_assoc p q r (Data.Either.left e) = Data.Either.left (Data.Either.left e)
To_or_assoc p q r (Data.Either.right pp (Data.Either qq rr) (Data.Either.left e)) = Data.Either.left (Data.Either.right e)
To_or_assoc p q r (Data.Either.right pp (Data.Either qq rr) (Data.Either.right e)) = Data.Either.right e
// to (Left p) = Left $ Left p
// to (Right (Left q)) = Left $ Right q
// to (Right (Right r)) = Right r

Fro_or_assoc (p) (q) (r) (e: Data.Either (Data.Either p q) r) : Data.Either p (Data.Either q r)
Fro_or_assoc p q r (Data.Either.left (Data.Either pp qq) rr (Data.Either.left e)) = Data.Either.left e
Fro_or_assoc p q r (Data.Either.left (Data.Either pp qq) rr (Data.Either.right e)) = Data.Either.right (Data.Either.left e)
Fro_or_assoc p q r (Data.Either.right (Data.Either pp qq) rr e) = Data.Either.right (Data.Either.right e)
// fro (Left (Left p)) = Left p
// fro (Left (Right q)) = Right $ Left q
// fro (Right r) = Right $ Right r

// We can now use these facts with rewrite and Refl to give smooth proofs of statements
// involving Iffs. Here is a ternary version of the previous mult_0 result:
Mult_0_3 (n: Data.Nat) (m: Data.Nat) (p: Data.Nat) : Iff (Prop.Equal Data.Nat (Data.Nat.mul n (Data.Nat.mul m p)) 0n) (Data.Either (Prop.Equal Data.Nat n 0n) (Data.Either (Prop.Equal Data.Nat m 0n) (Prop.Equal Data.Nat p 0n)))
Mult_0_3 n m p = Data.Pair.new ((x: (Prop.Equal Data.Nat (Data.Nat.mul n (Data.Nat.mul m p)) 0n)) => To_mult_0_3 n m p x) ((y: Data.Either (Prop.Equal Data.Nat n 0n) (Data.Either (Prop.Equal Data.Nat m 0n) (Prop.Equal Data.Nat p 0n))) => Fro_mult_0_3 n m p y)
// mult_0_3 : (n * m * p = Z) <‡±¶>
// ((n = Z) `Data.Either` ((m = Z) `Data.Either` (p = Z)))
// mult_0_3 = (to, fro)
// where
To_mult_0_3 (n: Data.Nat) (m: Data.Nat) (p: Data.Nat) (e: (Prop.Equal Data.Nat (Data.Nat.mul n (Data.Nat.mul m p)) 0n)) : (Data.Either (Prop.Equal Data.Nat n 0n) (Data.Either (Prop.Equal Data.Nat m 0n) (Prop.Equal Data.Nat p 0n)))
To_mult_0_3 n m p e = //Data.Either.swap (Data.Pair.snd (Or_assoc (Prop.Equal m 0n) (Prop.Equal p 0n) (Prop.Equal n 0n)))
	let snd = (Data.Pair.snd (Or_assoc (Prop.Equal m 0n) (Prop.Equal p 0n) (Prop.Equal n 0n))) :: (_) -> (_)
	let auy = (Data.Pair.fst (Mult_0 m p )) :: (_) -> (_)
	// let auw Data.Either left right =  (Mult_ep_0 n (Data.Nat.mul m p) e) 
	// let aux = To_mult_0_3.Aux m p e
	// Data.Either.swap ?
	?
// To_mult_0_3.Aux (m: Data.Nat) (p: Data.Nat) (e: (Prop.Equal Data.Nat (Data.Nat.mul m p) 0n)) : (Data.Either (Prop.Equal Data.Nat m 0n) (Prop.Equal Data.Nat p 0n))
// To_mult_0_3.Aux m p e = ((Data.Pair.fst (Mult_0 m p )) :: (_) -> (_)) e
	// let auz = match Data.Either auw with {
	// 	right => auw.val
	// 	left => ?

	// }: (Prop.Equal Data.Nat (Data.Nat.mul m p) 0n) 
	// let fin = snd ?
	// ?

	// (Data.Either (Prop.Equal Data.Nat n 0n) (Data.Either (Prop.Equal Data.Nat m 0n) (Prop.Equal Data.Nat p 0n)))
	// ‚Ä¢ aux : (Data.Pair ((x_1 : ) -> (Data.Either (Data.Either (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n)) (Prop.Equal Data.Nat p 0n))) ((x_2 ) -> (Data.Either (Prop.Equal Data.Nat n 0n) (Data.Either (Prop.Equal Data.Nat m 0n) (Prop.Equal Data.Nat p 0n))))
	// to : (n * m * p = Z) ‡±è> ((n = Z) `Data.Either` ((m = Z) `Data.Either` (p = Z)))
// to {n} {m} {p} prf = let
// (nm_p_to, _) = mult_0 {n=(n*m)} {m=p}
// (n_m_to, _) = mult_0 {n} {m}
// (_, or_a_fro) = or_assoc {p=(n=Z)} {q=(m=Z)} {r=(p=Z)}
// in or_a_fro  case nm_p_to prf of
// Left prf ‡±¨> Left $ n_m_to prf
// Right prf ‡±¨> Right prf
Mult_comm (n: Data.Nat) (m: Data.Nat) : (Prop.Equal Data.Nat (Data.Nat.mul m n) (Data.Nat.mul n m))
Mult_assoc (n: Data.Nat) (m: Data.Nat) (p: Data.Nat) : (Prop.Equal Data.Nat (Data.Nat.mul n (Data.Nat.mul m p)) (Data.Nat.mul (Data.Nat.mul n m) p))
Mult_0_r (n: Data.Nat) : (Prop.Equal Data.Nat (Data.Nat.mul n Data.Nat.zero) Data.Nat.zero)

Fro_mult_0_3 (n: Data.Nat) (m: Data.Nat) (p: Data.Nat) (e: Data.Either (Prop.Equal Data.Nat n 0n) (Data.Either (Prop.Equal Data.Nat m 0n) (Prop.Equal Data.Nat p 0n))) : (Prop.Equal Data.Nat (Data.Nat.mul n (Data.Nat.mul m p)) 0n)
Fro_mult_0_3 Data.Nat.zero m p (Data.Either.left Prop.Equal.refl) = Prop.Equal.refl
Fro_mult_0_3 n Data.Nat.zero p (Data.Either.right a (Data.Either b c) (Data.Either.left Prop.Equal.refl)) = Mult_comm 0n n
Fro_mult_0_3 n m Data.Nat.zero (Data.Either.right a (Data.Either b c) (Data.Either.right Prop.Equal.refl)) = Prop.Equal.chain (Mult_assoc n m 0n) (Mult_0_r (Data.Nat.mul n m))
Fro_mult_0_3 (Data.Nat.succ n) m p (Data.Either.left e) = 
	let p = (Prop.Equal.rewrite 
			e
			(x => match Data.Nat x {
				zero => Data.Empty
				succ => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
		Data.Empty.absurd p
Fro_mult_0_3 n (Data.Nat.succ m) p (Data.Either.right a (Data.Either b c) (Data.Either.left e)) = 
	let p = (Prop.Equal.rewrite 
			e
			(x => match Data.Nat x {
				zero => Data.Empty
				succ => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
		Data.Empty.absurd p
Fro_mult_0_3 n m (Data.Nat.succ p) (Data.Either.right a (Data.Either b c) (Data.Either.right e)) = 
	let p = (Prop.Equal.rewrite 
			e
			(x => match Data.Nat x {
				zero => Data.Empty
				succ => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
		Data.Empty.absurd p

// fro : ((n = Z) `Data.Either` ((m = Z) `Data.Either` (p = Z))) ‡±è> (n * m * p = Z)
// fro (Left Refl) = Refl
// fro {n} (Right (Left Refl)) = rewrite multZeroRightZero n in Refl
// fro {n} {m} (Right (Right Refl)) = rewrite multZeroRightZero (n*m) in Refl
// The apply tactic can also be used with <‡±¶>. When given an Iff as its
// argument, apply tries to guess which side of the Iff to use.
Apply_iff_example (n: Data.Nat) (m: Data.Nat) (e: Prop.Equal Data.Nat (Data.Nat.mul n m) 0n) : Data.Either (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n) 
Apply_iff_example n m e = ((Data.Pair.fst (Mult_0 n m)) :: (_) ->(_)) e 

// apply_iff_example : (n, m : Data.Nat) ‡±è> n * m = Z ‡±è> ((n = Z) `Data.Either` (m = Z))
// apply_iff_example n m = fst $ mult_0 {n} {m}

// 1.6. Existential Quantification. Another important logical connective is
// existential quantification. To say that there is some x of type t such that some
// property p holds of x, we write (x : t ** p). The type annotation : t can be omitted
// if Idris is able to infer from the context what the type of x should be.
// To prove a statement of the form (x ** p), we must show that p holds for some
// specific choice of value for x, known as the witness of the existential. This is done
// in two steps: First, we explicitly tell Idris which witness t we have in mind by
// writing it on the left side of **. Then we prove that p holds after all occurrences
// of x are replaced by t.

// record Data.Sigma (x) (p: x -> Type) {
//   fst : x
//   snd : (p fst)
// }



// Sigmat (a: Type) (p: a -> Type) : Type
// Sigmat.new <a> <p: a -> Type> (fst: a) (snd: p fst) : Sigmat a p

// data DPair : (a : Type) -> (P : a -> Type) -> Type where
//    MkDPair : {P : a -> Type} -> (x : a) -> P x -> DPair a P


// type Data.Sigma (a) (f: a -> Type) {
// 	new (fst: a) (snd: f fst)
// }		

// four_is_even : (n : Data.Nat ** 4 = n + n)

// Four_is_even : [n: Data.Nat] -> (Prop.Equal Data.Nat 4n (Data.Nat.add n n))
// Four_is_even : Data.Sigma Data.Nat (n => (Prop.Equal Data.Nat 4n (Data.Nat.add n n)))

// Four_is_even = Data.Sigma.new 2n Prop.Equal.refl
// Four_is_even = $ 2n Prop.Equal.refl


// Conversely, if we have an existential hypothesis (x ** p) in the context, we can
// pattern match on it to obtain a witness x and a hypothesis stating that p holds of
// x.
// Exists_example_2 (s: Data.Sigma Data.Nat (m => (Prop.Equal Data.Nat n (Data.Nat.add 4n m)))) : (o : Data.Nat ** n = 2 + o)
Exists_example_2 (n: Data.Nat) (p: [m: Data.Nat] -> (Prop.Equal Data.Nat n (Data.Nat.add 4n m))) : [o: Data.Nat] -> (Prop.Equal Data.Nat n (Data.Nat.add 2n o))
// Exists_example_2 n (Data.Sigma.new a (f) m prf) = $ (Data.Nat.add 2n m) (Prop.Equal.apply (x => x) prf)
// 	let e = prf
// 	?)

// Data.Nat : Type
// Data.Nat.zero : Data.Nat
// Data.Nat.succ (pred: Data.Nat) : Data.Nat

// Prop.Equal <x> (a: x) (b: x) : Type
// Prop.Equal.refl <x> <a: x> : Prop.Equal a a 
// Prop.Equal.mirror <x> <a: x> <b: x> (c: Prop.Equal x a b) : Prop.Equal x b a
// Prop.Equal.apply <x> <y> <a: x> <b: x> (f: x -> y) (c: Prop.Equal x a b) : Prop.Equal y (f a) (f b)
// Prop.Equal.chain <x> <a: x> <b: x> <c: x> (e: Prop.Equal x a b) (f: Prop.Equal x b c) : Prop.Equal x a c

// Exists_example_3 (s: Data.Sigma Data.Nat (m => Data.Sigma Data.Nat (n => (Prop.Equal Data.Nat n (Data.Nat.add (U60.to_nat 4) m))))) : Data.Sigma Data.Nat (o => Data.Sigma Data.Nat (n => (Prop.Equal Data.Nat n (Data.Nat.add (U60.to_nat 2) o))))
// Exists_example_3 (Data.Sigma.new m e) = $ (Data.Nat.add (Data.Nat.succ(Data.Nat.succ Data.Nat.zero)) m) ($ ? ?)  

// exists_example_2 : (m : Data.Nat ** n = 4 + m) ‡±è> (o : Data.Nat ** n = 2 + o)
// exists_example_2 (m ** pf) = (2 + m ** pf)

// 1.6.1. Exercise: 1 star (dist_not_exists). Prove that ‚Äúp holds for all x‚Äù implies
// ‚Äúthere is no x for which p does not hold.‚Äù

Dist_not_exists <a> <p: a -> Type> (f: (x: a) -> (p x)) : Not (Data.Sigma a (x => ( Not (p x))))
// Dist_not_exists a p f = ?
// dist_not_exists : {p : a ‡±è> Type} ‡±è> ((x : a) ‡±è> p x) ‡±è> Not (x ** Not $ p x)
// dist_not_exists f = ?dist_not_exists_rhs
// ‚ñ°
// 1.6.2. Exercise: 2 stars (dist_exists_or). Prove that existential quantification
// distributes over disjunction.
Dist_exists_or <a> <p: a -> Type> <q: a -> Type> : Iff (Data.Sigma a (x => (Data.Either (p x) (q x)))) (Data.Either (Data.Sigma a (x => (p x))) (Data.Sigma a (x => (q x))))
// dist_exists_or : {p, q : a ‡±è> Type} ‡±è> (x ** (p x `Data.Either` q x)) <‡±¶>
// ((x ** p x) `Data.Either` (x ** q x))
// Dist_exists_or a p q = ?dist_exists_or_rhs
// ‚ñ°


// 2. Programming with Propositions
// The logical connectives that we have seen provide a rich vocabulary for defining
// complex propositions from simpler ones. To illustrate, let‚Äôs look at how to express
// the claim that an element x occurs in a list l. Notice that this property has a
// simple recursive structure:
// ‚Ä¢ If l is the empty list, then x cannot occur on it, so the property ‚Äúx appears
// in l‚Äù is simply false.
// ‚Ä¢ Otherwise, l has the form x' ‡Øù‡Øû xs. In this case, x occurs in l if either it
// is equal to x' or it occurs in xs.
// We can translate this directly into a straightforward recursive function from taking
// an element and a list and returning a proposition:


In <a> (x: a) (l: Data.List a) : Type
In a x Data.List.nil = Data.Empty
In a x (Data.List.cons head tail) = Data.Either (Prop.Equal a x head) (In a x tail) 
// In : (x : a) ‡±è> (l : Data.List a) ‡±è> Type
// In x [] =  
// In x (x' ‡Øù‡Øû xs) = (x' = x) `Data.Either` In x xs
// When In is applied to a concrete list, it expands into a concrete sequence of nested
// disjunctions.

In_example_1 : In 4n [1n, 2n, 3n, 4n, 5n]
In_example_1 = Data.Either.right (Data.Either.right (Data.Either.right (Data.Either.left Prop.Equal.refl)))
// In_example_1 : In 4 [1, 2, 3, 4, 5]
// In_example_1 = Right $ Right $ Right $ Left Refl

// In_example_2 (n: Data.Nat) (i: In n [2n, 4n]) : Data.Sigma Data.Nat (m => (Prop.Equal n (Data.Nat.mul 2n m)))
In_example_2 (n: Data.Nat) (i: In n [2n, 4n]) : Data.Sigma Data.Nat (m => Prop.Equal Data.Nat n (Data.Nat.mul 2n m))
In_example_2 n (Data.Either.left e) = $ 1n e
In_example_2 n (Data.Either.right l (Data.Either rl rr) (Data.Either.left e)) = $ 2n e
In_example_2 n (Data.Either.right l (Data.Either rl rr) (Data.Either.right e))	= Data.Empty.absurd e

// In_example_2 (n: Data.Nat) (i: In n [2n, 4n]) : Data.Sigma Data.Nat (m => Prop.Equal Data.Nat n (Data.Nat.mul 2n m))
// In_example_2 n (Data.Either.left e)            = $ 1n e
// // In_example_2 n (Data.Either.right e)           = $ 2n (Data.Either.lft e) // funciona 
// In_example_2 n (Data.Either.right l r (Data.Either.left ll rr e)) = Data.Sigma.new 2n e // n√£o funciona 
// // In_example_2 n (Data.Either.right e)           = Data.Empty.absurd (Data.Either.rgt e) // funciona 
// In_example_2 n (Data.Either.right l r (Data.Either.right ll rr e)) = Data.Empty.absurd e // n√£o funciona 

// In_example_2 (Left Refl) = (1 ** Refl)
// In_example_2 (Right $ Left Refl) = (2 ** Refl)
// In_example_2 (Right $ Right prf) = absurd prf
// (Notice the use of absurd to discharge the last case.)
// We can also prove more generic, higher-level lemmas about In.
// Note, in the next, how In starts out applied to a variable and only gets expanded
// when we do case analysis on this variable:

Map <x> <y> (func: x -> y) (l: (Data.List x)) : (Data.List y)
Map func Data.List.nil = Data.List.nil
Map func (Data.List.cons head tail) = Data.List.cons (func head) (Map func tail)

// 2. PROGRAMMING WITH PROPOSITIONS 79
In_map <a> <b> (f: a -> b) (l: Data.List a) (x: a) (i: In x l) : In (f x) (Map f l)
In_map a b f Data.List.nil x i = Data.Empty.absurd i
In_map a b f (Data.List.cons head tail) x (Data.Either.left e) = Prop.Equal.rewrite e (k => (Data.Either (Prop.Equal (f x) (f k)) _)) (Data.Either.left Prop.Equal.refl)
In_map a b f (Data.List.cons head tail) x (Data.Either.right e) = Data.Either.right (In_map f tail x e)
// In_map : (f : a ‡±è> b) ‡±è> (l : Data.List a) ‡±è> (x : a) ‡±è> In x l ‡±è>
// In (f x) (map f l)
// In_map _ [] _ ixl = absurd ixl
// In_map f (x' ‡Øù‡Øû xs) x (Left prf) = rewrite prf in Left Refl
// In_map f (x' ‡Øù‡Øû xs) x (Right r) = Right $ In_map f xs x r

// This way of defining propositions recursively, though convenient in some cases,
// also has some drawbacks. In particular, it is subject to Idris‚Äôs usual restrictions
// regarding the definition of recursive functions, e.g., the requirement that they be
// ‚Äúobviously terminating.‚Äù In the next chapter, we will see how to define propositions
// inductively, a different technique with its own set of strengths and limitations.
// 2.0.1. Exercise: 2 stars (In_map_iff).
In_map_iff <a> <b> (f: a -> b) (l: Data.List a) (y: b) : Iff (In y (Map f l)) (Data.Sigma a (x => (Data.Pair (Prop.Equal (f x) y) (In x l))))
// In_map_iff : (f : a ‡±è> b) ‡±è> (l : Data.List a) ‡±è> (y : b) ‡±è>
// (In y (map f l)) <‡±¶> (x ** (f x = y, In x l))
// In_map_iff a b f l y = ?In_map_iff
// ‚ñ°
// 2.0.2. Exercise: 2 stars (in_app_iff).

// Iff.refl <p> : Iff p p
// Iff.refl p = (Data.Pair.new p p (p => p) (p => p))

// Iff.chain (p) (q) (r) (e0: Iff p q) (e1: Iff q r) : Iff p r
// Iff.chain p q r e0 (Iff.refl x) = e0 :: Iff p x

// Iff.mirror <p> <q> (e: Iff p q) : Iff q p
// Iff.mirror p q (Data.Pair.new lft rgt) = (Data.Pair.new rgt lft)

// App_nil_r <x> (l: Data.List x) : (Prop.Equal (Data.List.concat l Data.List.nil) l)

Data.Either.swap.prf <l> <r> : Prop.Equal (Data.Either l r) (Data.Either r l) 
Data.Either.swap.prf l r = 
	let r = Prop.Equal.rewrite _ (x => (Prop.Equal (Data.Either l r) x)) Prop.Equal.refl
	r
	


In_app_iff <a> (x: a) (lx: Data.List a) (ly: Data.List a) : Iff (In x (Data.List.concat lx ly)) (Data.Either (In x lx) (In x ly))  
// In_app_iff a x Data.List.nil ly = 
	// let t = Data.Either.swap.prf (In x ly) Data.Empty
	// let l = In_app_iff a x ly Data.List.nil
	// let f = App_nil_r ly
	// let r = Prop.Equal.rewrite f (k => (Iff (In x (k)) (Data.Either (In x ly) Data.Empty))) ?
	// let z = Prop.Equal.rewrite t (k => (Iff (In a x ly) k)) r
	// z
	// Iff.refl :: (Iff _ (Data.Either Data.Empty (In a x ly)))

	


	
 // in_app_iff : (In a (l++l')) <‡±¶> (In a l `Data.Either` In a l')
// in_app_iff = ?in_app_iff_rhs
// ‚ñ°
// 2.0.3. Exercise: 3 stars (All). Recall that functions returning propositions can
// be seen as properties of their arguments. For instance, if p has type Data.Nat ‡±è> Type,
// then p n states that property p holds of n.
// Drawing inspiration from In, write a recursive function All stating that some property p holds of all elements of a list l. To make sure your definition is correct,
// prove the All_In lemma below. (Of course, your definition should not just restate
// the left-hand side of All_In.)

All <t> (p: t -> Type) (l: Data.List t) : Type
All t p Data.List.nil = Data.Empty
All t p (Data.List.cons head tail) = Data.Pair (p head) (All p tail)
// All t p l = ?All
// All : (p : t ‡±è> Type) ‡±è> (l : Data.List t) ‡±è> Type
// All p l = ?All_rhs
All_in <t> (p: t -> Type) (l: Data.List t) : Iff ((x: t) -> (i: In x l) -> p x) (All p l) 

All_in t p l =  Data.Pair.new ((x: (x: t) -> (In x l) -> (p x)) => All_in_to t p l x) ((x: All p l) => All_in_fro t p l x)

All_in_to <t> (p: t -> Type) (l: Data.List t) (e: (x: t) -> (In x l) -> (p x)) : (All p l) 
All_in_to  t p Data.List.nil e = Data.Empty.absurd _
All_in_to t p (Data.List.cons r head tail) e = 
	let left = e head
	let left = left (Data.Either.left Prop.Equal.refl)
	let right = All_in_to p tail (x => i => e x (Data.Either.right i))
	Data.Pair.new (left) (right)

All_in_fro <t> (p: t -> Type) (l: Data.List t) (e: All p l) : (x: t) -> (In x l) -> (p x)
All_in_fro t p Data.List.nil e = Data.Empty.absurd _
All_in_fro t p (Data.List.cons r head tail) (Data.Pair.new fst snd) = x => i => 
	let body = All_in_fro p tail snd
	match Data.Either i {
		left => Data.Empty.absurd _ //TODO
		right => (body x i.val) 
	}
		

// 2.0.4. Exercise: 3 stars (combine_odd_even). Complete the definition of the
// combine_odd_even function below. It takes as arguments two properties of numbers,
// podd and peven, and it should return a property p such that p n is Iffalent to
// podd n when n is odd and Iffalent to peven n otherwise.
Evenb (n: Data.Nat) : Data.Bool
Evenb Data.Nat.zero = Data.Bool.true
Evenb (Data.Nat.succ Data.Nat.zero) = Data.Bool.false
Evenb (Data.Nat.succ (Data.Nat.succ n)) = Evenb n

Odd (n: Data.Nat) : Data.Bool
Odd Data.Nat.zero = Data.Bool.false
Odd (Data.Nat.succ Data.Nat.zero) = Data.Bool.true
Odd (Data.Nat.succ (Data.Nat.succ n)) = Odd n

Evenb_S (n: Data.Nat) : (Prop.Equal Data.Bool (Evenb (Data.Nat.succ n)) (Data.Bool.not (Evenb n)))
// Evenb_S n = Prop.Equal.refl

Combine.odd.even (podd: (o: Data.Nat) -> Type) 
								 (peven: (e: Data.Nat) -> Type) : Data.Nat -> Type
Combine.odd.even podd peven = n => Data.Bool.if _ (Odd n) (podd n) (peven n)

// To test your definition, prove the following facts:
// Nat_Succ_N (n: Data.Nat) : Prop.Equal (Data.Nat.succ n) n


Combine.odd.even.intro.go (n: Data.Nat) : Data.Either (Prop.Equal Data.Bool (Odd n) Data.Bool.true) (Prop.Equal Data.Bool (Odd n) Data.Bool.false)
Combine.odd.even.intro.go Data.Nat.zero = Data.Either.right Prop.Equal.refl
Combine.odd.even.intro.go (Data.Nat.succ Data.Nat.zero) = Data.Either.left Prop.Equal.refl
Combine.odd.even.intro.go (Data.Nat.succ (Data.Nat.succ n)) = (Combine.odd.even.intro.go n)

Ero (n: Data.Nat) : Prop.Equal Data.Nat (n) (Data.Nat.succ (Data.Nat.succ n)) 

Combine.odd.even.intro (n: Data.Nat) 
												(podd: (o: Data.Nat) -> Type) 
												(peven: (e: Data.Nat) -> Type) 
												(i: (Prop.Equal (Odd n) Data.Bool.true ) -> podd n) 
												(p: (Prop.Equal (Odd n) Data.Bool.false) -> peven n) : 
												(Combine.odd.even podd peven) n
	
Combine.odd.even.intro Data.Nat.zero odd even i p = (p Prop.Equal.refl)
Combine.odd.even.intro (Data.Nat.succ Data.Nat.zero) odd even oddp evenp = (oddp Prop.Equal.refl)
// Combine.odd.even.intro (Data.Nat.succ (Data.Nat.succ n)) odd even oddp evenp = 
// 	let ind = Combine.odd.even.intro n (odd) (even) (x => ?) (y => ?)



Combine.odd.even.elim.odd (n: Data.Nat) (podd: (o: Data.Nat) -> Type) (peven: (e: Data.Nat) -> Type) (e: (Combine.odd.even (podd) (peven)) n) (p: (Prop.Equal (Odd n) Data.Bool.true)) : podd n
// Combine.odd.even.elim.odd Data.Nat.zero podd pevem e p = ?
// Combine.odd.even.elim.odd (Data.Nat.succ n) podd pevem e p = ?
// Combine.odd.even.elim.odd (Data.Nat.succ (Data.Nat.succ n)) podd pevem e p = ?


Combine.odd.even.elim.even (n: Data.Nat) (podd: (o: Data.Nat) -> Type) (peven: (e: Data.Nat) -> Type) (e: (Combine.odd.even (podd) (peven)) n) (p: (Prop.Equal (Odd n) Data.Bool.false)) : peven n



// 3. Applying Theorems to Arguments
// One feature of Idris that distinguishes it from many other proof assistants is that
// it treats proofs as first-class objects.
// ‚Äònameref‚Äò the chapters when they‚Äôre done
// There is a great deal to be said about this, but it is not necessary to understand
// it in detail in order to use Idris. This section gives just a taste, while a deeper
// exploration can be found in the optional chapters ProofObjects and IndPrinciples.
// We have seen that we can use the :t command to ask Idris to print the type of an
// expression. We can also use :t to ask what theorem a particular identifier refers
// to.
// ŒªŒ†> :t plusCommutative
// plusCommutative : (left : Data.Nat) ‡±è> (right : Data.Nat) ‡±è> left + right = right + left
Plus.Commutative (left: Data.Nat) (right: Data.Nat) : Prop.Equal Data.Nat (Data.Nat.add left right) (Data.Nat.add right left)
// Plus.Commutative left right = ?
// Idris prints the statement of the plusCommutative theorem in the same way that it
// prints the type of any term that we ask it to check. Why?
// The reason is that the identifier plusCommutative actually refers to a proof object ‚Äì a
// data structure that represents a logical derivation establishing of the truth of the
// statement (n, m : Data.Nat) ‡±è> n + m = m + n. The type of this object is the statement of
// the theorem that it is a proof of.
// Intuitively, this makes sense because the statement of a theorem tells us what we
// can use that theorem for, just as the type of a computational object tells us what
// we can do with that object ‚Äì e.g., if we have a term of type Data.Nat ‡±è> Data.Nat ‡±è> Data.Nat, we
// can give it two Nats as arguments and get a Data.Nat back. Similarly, if we have an
// object of type n = m ‡±è> n + n = m + m and we provide it an ‚Äúargument‚Äù of type n = m,
// we can derive n + n = m + m.
// Operationally, this analogy goes even further: by applying a theorem, as if it were
// a function, to hypotheses with matching types, we can specialize its result without
// having to resort to intermediate assertions. For example, suppose we wanted to
// prove the following result:

Plus.comm3 (n: Data.Nat) (m: Data.Nat) (p: Data.Nat) : Prop.Equal Data.Nat (Data.Nat.add n (Data.Nat.add m p)) (Data.Nat.add (Data.Nat.add p m ) n)
// Plus.comm3 n m p = 

// Edit, we have already done this in previous chapters (add a hyperlink?)
// It appears at first sight that we ought to be able to prove this by rewriting with
// plusCommutative twice to make the two sides match. The problem, however, is that
// the second rewrite will undo the effect of the first.
// Proof.
// intros n m p.
// rewrite plus_comm.
// rewrite plus_comm.
// (* We are back where we started... *)
// Abort.
// One simple way of fixing this problem, using only tools that we already know, is
// to use assert to derive a specialized version of plus_comm that can be used to
// rewrite exactly where we want.
// Lemma plus_comm3_take2 :
// ‚àÄn m p, n + (m + p) = (p + m) + n.
// Proof.
// intros n m p.
// rewrite plus_comm.
// assert (H : m + p = p + m).
// { rewrite plus_comm. reflexivity. }
// rewrite H.
// reflexivity.
// Qed.
// A more elegant alternative is to apply plusCommutative directly to the arguments
// we want to instantiate it with, in much the same way as we apply a polymorphic
// function to a type argument.
// plus_comm3 n m p = rewrite plusCommutative n (m+p) in
// rewrite plusCommutative m p in Refl
// You can ‚Äúuse theorems as functions‚Äù in this way with almost all tactics that take a
// theorem name as an argument. Note also that theorem application uses the same
// inference mechanisms as function application; thus, it is possible, for example, to
// supply wildcards as arguments to be inferred, or to declare some hypotheses to a
// theorem as implicit by default. These features are illustrated in the proof below.

Lemma_application_ex (n: Data.Nat) (ns: Data.List Data.Nat) (i: In n (Map (m => (Data.Nat.mul m 0n)) ns)) : Prop.Equal Data.Nat n 0n
Lemma_application_ex n Data.List.nil prf = Data.Empty.absurd prf
Lemma_application_ex n (Data.List.cons head tail) (Data.Either.left prf) = Prop.Equal.rewrite (Mult_0_r head) (x => (Prop.Equal Data.Nat n x)) prf
Lemma_application_ex n (Data.List.cons head tail) (Data.Either.right prf) = Lemma_application_ex n tail prf
// lemma_application_ex : (n : Data.Nat) ‡±è> (ns : Data.List Data.Nat) ‡±è>
// In n (map (\m ‡±¨> m * 0) ns) ‡±è> n = 0
// lemma_application_ex _ [] prf = absurd prf
// lemma_application_ex _ (y ‡Øù‡Øû _) (Left prf) =
// rewrite sym $ multZeroRightZero y in sym prf
// lemma_application_ex n (_ ‡Øù‡Øû xs) (Right prf) =
// lemma_application_ex n xs prf
// We will see many more examples of the idioms from this section in later chapters.




// 4. Idris vs. Set Theory
// Edit, Idris‚Äôs core is likely some variant of MLTT
// Coq‚Äôs logical core, the Calculus of Inductive Constructions, differs in some important ways from other formal systems that are used by mathematicians for writing
// down precise and rigorous proofs. For example, in the most popular foundation for
// mainstream paper-and-pencil mathematics, Zermelo-Fraenkel Set Theory (ZFC),
// a mathematical object can potentially be a member of many different sets; a term
// in Idris‚Äôs logic, on the other hand, is a member of at most one type. This difference
// often leads to slightly different ways of capturing informal mathematical concepts,
// but these are, by and large, quite Natural and easy to work with. For example,
// instead of saying that a natural number n belongs to the set of even numbers, we
// would say in Idris that ev n holds, where ev : Data.Nat ‡±è> Type is a property describing
// even numbers.
// However, there are some cases where translating standard mathematical reasoning
// into Idris can be either cumbersome or sometimes even impossible, unless we enrich
// the core logic with additional axioms. We conclude this chapter with a brief
// discussion of some of the most significant differences between the two worlds.
// 4.1. Functional Extensionality. The equality assertions that we have seen
// so far mostly have concerned elements of inductive types (Data.Nat, Data.Bool, etc.). But since
// Idris‚Äôs equality operator is polymorphic, these are not the only possibilities ‚Äì in
// particular, we can write propositions claiming that two functions are equal to e
Function_equality_ex1 : Prop.Equal Data.Nat (Data.Nat.succ 3n) (Data.Nat.succ (Data.Nat.pred 4n))
Function_equality_ex1 = Prop.Equal.refl
// function_equality_ex1 : plus 3 = plus (pred 4)
// function_equality_ex1 = Refl
// In common mathematical practice, two functions f and g are considered equal if
// they produce the same outputs:

// (‚àÄùë•, ùëì(ùë•) = ùëî(ùë•)) ‚Üí ùëì = ùëî

// This is known as the principle of functional extensionality.
// 4. IDRIS VS. SET THEORY 83
// Informally speaking, an ‚Äúextensional property‚Äù is one that pertains to an object‚Äôs
// observable behavior. Thus, functional extensionality simply means that a function‚Äôs identity is completely determined by what we can observe from it ‚Äì i.e., in
// Idris terms, the results we obtain after applying it.
// Functional extensionality is not part of Idris‚Äôs basic axioms. This means that some
// ‚Äúreasonable‚Äù propositions are not provable.

// Function_equality_ex2 : Prop.Equal ((x: Data.Nat) => (Data.Nat.add x 1n)) ((x: Data.Nat) => (Data.Nat.add 1n x))
// Function_equality_ex2 = ?

// Explain believe_me vs really_believe_me?
// However, we can add functional extensionality to Idris‚Äôs core logic using the
// really_believe_me command.

// functional_extensionality : ((x : a) ‡±è> f x = g x) ‡±è> f = g
Functional_extensionality <a> <b> <f: a -> b> <g: a -> b> (e: (x: a) -> (Prop.Equal b (f x) (g x))) : Prop.Equal f g

// functional_extensionality = really_believe_me

// Using really_believe_me has the same effect as stating a theorem and skipping its
// proof using a hole, but it alerts the reader (and type checker) that this isn‚Äôt just
// something we‚Äôre going to come back and fill in later!
// We can now invoke functional extensionality in proofs:
Function_equality_ex2 : Prop.Equal ((x: Data.Nat) => (Data.Nat.add x 1n)) ((x: Data.Nat) => (Data.Nat.add 1n x))
Function_equality_ex2 = Functional_extensionality (x => Plus.Commutative x 1n) 
// function_equality_ex2 = functional_extensionality $ \x ‡±¨> plusCommutative x 1
// Naturally, we must be careful when adding new axioms into Idris‚Äôs logic, as they
// may render it inconsistent ‚Äì that is, they may make it possible to prove every
// proposition, including Void!
// Unfortunately, there is no simple way of telling whether an axiom is safe to add:
// hard work is generally required to establish the consistency of any particular combination of axioms.
// However, it is known that adding functional extensionality, in particular, is consistent.
// Is there such a command in Idris?
// To check whether a particular proof relies on any additional axioms, use the
// Print Assumptions command.
// Print Assumptions function_equality_ex2.
// (* ‡±∫‡≤Ñ‡±Æ>
// Axioms:
// functional_extensionality :
// forall (X Y : Type) (f g : X ‡±è> Y),
// (forall x : X, f x = g x) ‡±è> f = g *)
// 84 6. LOGIC : LOGIC IN IDRIS
// 4.1.1. Exercise: 4 stars (tr_rev). One problem with the definition of the list reversing function rev that we have is that it performs a call to ++ on each step;
// running ++ takes time asymptotically linear in the size of the list, which means
// that rev has quadratic running time.
// We can improve this with the following definition:
Rev_append <x> (l1: Data.List x) (l2: Data.List x) : Data.List x
Rev_append x Data.List.nil l2 = l2
Rev_append x (Data.List.cons head tail) l2 = Rev_append tail (Data.List.cons head l2)
// rev_append : (l1, l2 : Data.List x) ‡±è> Data.List x
// rev_append [] l2 = l2
// rev_append (x ‡Øù‡Øû xs) l2 = rev_append xs (x ‡Øù‡Øû l2)
Tr_rev <x> (l: Data.List x) : Data.List x
Tr_rev x l = Rev_append l Data.List.nil

// tr_rev : (l : Data.List x) ‡±è> Data.List x
// tr_rev l = rev_append l []
Rev_involutive <x> (l: Data.List x) : (Prop.Equal (Data.List x) (Rev (Rev l)) l)

Rev_app_distr <x> (l1: Data.List x) (l2: Data.List x) : (Prop.Equal (Data.List x) (Rev (App l1 l2)) (App (Rev l2) (Rev l1)))

App_assoc <a> (l: Data.List a) (m: Data.List a) (n: Data.List a) : (Prop.Equal (Data.List a) (App l (App m n)) (App (App l m) n)) 

App_assoc4 <a> (l1: (Data.List a)) (l2: (Data.List a)) (l3: (Data.List a)) (l4: (Data.List a)) : (Prop.Equal (Data.List a) (App l1 (App l2 (App l3 l4))) (App (App (App l1 l2) l3) l4))

App_nil_r <x> (l: Data.List x) : Prop.Equal (Data.List x) (App l Data.List.nil) l

Rev <x> (l: Data.List x) : Data.List x
Rev Data.List.nil = Data.List.nil                      // #######[head]#######
Rev (Data.List.cons x head tail) = App (Rev tail) (Data.List.cons head Data.List.nil) 

App <a> (l1: Data.List a) (l2: Data.List a) : Data.List a
App (Data.List.nil ) l2 = l2
App (Data.List.cons x head tail) l2 = Data.List.cons head (App tail l2) 
// (This is very similar to how reverse is defined in Prelude.Data.List.)
// This version is said to be tail-recursive, because the recursive call to the function
// is the last operation that needs to be performed (i.e., we don‚Äôt have to execute ++
// after the recursive call); a decent compiler will generate very efficient code in this
// case. Prove that the two definitions are indeed Iffalent.
// Tr_rev_app_distr <x> (l1: Data.List x) (l2: Data.List x) : (Prop.Equal (Data.List x) (Tr_rev (App l1 l2)) (App (Tr_rev l2) (Tr_rev l1)))
// Tr_rev_app_distr x Data.List.nil l2 = 
// 	let aux = App_nil_r (Rev_append l2 [])
// 	Prop.Equal.mirror aux
// Tr_rev_app_distr x (Data.List.cons head tail) l2 = 
// 	let ind = Tr_rev_app_distr tail l2
// 	let ind = Tr_rev_app_distr tail (Data.List.cons head l2)
// 	let aux = App_assoc (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil))) []
// 	let auy = App_nil_r (Rev_append tail (Data.List.cons head (Data.List.nil))) 
// 	let rrt = Prop.Equal.rewrite auy (x => (Prop.Equal (App (Rev_append l2 (Data.List.nil)) x) _)) aux
// 	let auy = App_nil_r ((App (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil))))) 
// 	let rrt = Prop.Equal.rewrite auy (x => (Prop.Equal _ (x))) aux

// ‚Ä¢ Expected: (Prop.Equal (Rev_append (App tail l2) (Data.List.cons head (Data.List.nil))) (App (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil))))) 
//  ‚Ä¢   ind  : (Prop.Equal (Rev_append (App tail l2) (Data.List.nil))                  (App (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.nil)))) 
//  ‚Ä¢   aux  : (Prop.Equal (App (Rev_append l2 (Data.List.nil)) (App (Rev_append tail (Data.List.cons head (Data.List.nil))) (Data.List.nil))) (App (App (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil)))) (Data.List.nil)))

//  ‚Ä¢   auy  : (Prop.Equal (App (App (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil)))) (Data.List.nil)) (App (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil))))) 
//  ‚Ä¢   rrt  : (Prop.Equal (App (Rev_append l2 (Data.List.nil)) (App (Rev_append tail (Data.List.cons head (Data.List.nil))) (Data.List.nil))) (App (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil))))) 

//  ‚Ä¢   auy  : (Prop.Equal (App (Rev_append tail (Data.List.cons head (Data.List.nil))) (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil))))
//  ‚Ä¢   rrt  : (Prop.Equal (App (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil)))) (App (App (Rev_append l2 (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil)))) (Data.List.nil)))

//  ‚Ä¢   aux  : (Prop.Equal (App (Rev_append (App tail l2) (Data.List.nil)) (Data.List.cons head (Data.List.nil))) (App (App (Rev_append (App tail l2) (Data.List.nil)) (Data.List.cons head (Data.List.nil))) (Data.List.nil)))
//  ‚Ä¢   aux  : (Prop.Equal (App (Rev_append tail (Data.List.nil)) (Data.List.cons head (Data.List.nil))) (App (App (Rev_append tail (Data.List.nil)) (Data.List.cons head (Data.List.nil))) (Data.List.nil))) 
//  ‚Ä¢   aux  : (Prop.Equal (App (Rev_append tail (Data.List.cons head (Data.List.nil))) (Data.List.cons head (Data.List.nil))) (App (App (Rev_append tail (Data.List.cons head (Data.List.nil))) (Data.List.cons head (Data.List.nil))) (Data.List.nil))) 

//  ‚Ä¢   ind  : (Prop.Equal (Rev_append (App tail (Data.List.cons head l2)) (Data.List.nil)) (App (Rev_append l2 (Data.List.cons head (Data.List.nil))) (Rev_append tail (Data.List.nil)))) 
//  ‚Ä¢   aux  : (Prop.Equal (App (Rev_append (App tail l2) (Data.List.nil)) (Data.List.cons head (Data.List.nil))) (App (App (Rev_append (App tail l2) (Data.List.nil)) (Data.List.cons head (Data.List.nil))) (Data.List.nil)))



Tr_rev_correct <a> (x: Data.List a) : Prop.Equal (Data.List a) (Tr_rev x) (Rev x) 
// // Tr_rev_correct a Data.List.nil = Prop.Equal.refl
// // Tr_rev_correct a (Data.List.cons head tail) = 
// // 	let ind = Tr_rev_correct a tail 
// // 	let app = Prop.Equal.apply (x => App x [head]) ind
// // 	let aux = Tr_rev_app_distr [head] tail
// // 	let chn = Prop.Equal.chain aux app
// // 	chn

// tr_rev_correct : (x : Data.List a) ‡±è> tr_rev x = rev x
// tr_rev_correct = ?tr_rev_correct_rhs


// Tr_rev_correct <a> (x: Data.List a) : Prop.Equal (Data.List a) (Tr_rev x) (Rev x) 
// Tr_rev_correct a Data.List.nil = Prop.Equal.refl
// Tr_rev_correct a (Data.List.cons head tail) = 
// 	let ind = Tr_rev_correct tail
// 	let app = Prop.Equal.apply (x => App x [head]) ind 
// 	let aux =	App_nil_r (Rev_append tail [head])
// 	let auy = App_assoc [] (Tr_rev tail) [head]
// 	?





// ‚Ä¢ Expected: (Prop.Equal (Rev_append tail (Data.List.cons head (Data.List.nil))) (App (Rev tail) (Data.List.cons head (Data.List.nil)))) 
//  ‚Ä¢   ind  : (Prop.Equal (Rev_append tail (Data.List.nil)) (Rev tail)) 
//  ‚Ä¢   app  : (Prop.Equal (App (Rev_append tail (Data.List.nil)) (Data.List.cons head (Data.List.nil))) (App (Rev tail) (Data.List.cons head (Data.List.nil)))) 
//  ‚Ä¢   aux  : (Prop.Equal (App (Rev_append tail (Data.List.cons head (Data.List.nil))) (Data.List.nil)) (Rev_append tail (Data.List.cons head (Data.List.nil))))
// Aux <a> (l: Data.List a) :              (App (Rev_append tail (Data.List.cons head (Data.List.nil))) (Data.List.nil)) (App (Rev_append tail (Data.List.nil)) (Data.List.cons head (Data.List.nil)))
Aux <a> (l1: Data.List a) (l2: Data.List a) : Prop.Equal (Rev_append l1 l2) (App (Tr_rev l1) l2)
// Aux  Data.List.nil l2 = Prop.Equal.refl
// Aux  (Data.List.cons head tail) l2 = 
// 	let ind = Aux tail l2
// 	let app = Prop.Equal.apply (x => Data.List.cons head x) ind
// 	let aux = Aux.aux head tail l2
// 	let auy = App_assoc4 [head] (Tr_rev tail) l2 []
// 	let auy = App_assoc4 [] (Tr_rev tail) [head] l2
// 	?
// ‚Ä¢Expected: (Prop.Equal (Rev_append tail (Data.List.cons head l2)) (App (Rev_append tail (Data.List.cons head (Data.List.nil))) l2)) 
// ‚Ä¢   ind  : (Prop.Equal (Rev_append tail l2) (App (Rev_append tail (Data.List.nil)) l2))
// ‚Ä¢   app  : (Prop.Equal (Data.List.cons head (Rev_append tail l2)) (Data.List.cons head (App (Rev_append tail (Data.List.nil)) l2)))
// ‚Ä¢   aux  : (Prop.Equal (Rev_append tail (Data.List.cons head l2)) (Data.List.cons head (Rev_append tail l2)))
// ‚Ä¢   auy  : (Prop.Equal (Data.List.cons head (App (Rev_append tail (Data.List.nil)) l2))) (Data.List.cons head (App (Rev_append tail (Data.List.nil)) l2))))

Aux.aux <a> (x: a) (l1: Data.List a) (l2: Data.List a) : Prop.Equal (Rev_append l1 (Data.List.cons x l2)) (Data.List.cons x (Rev_append l1 l2))
Aux.aux x Data.List.nil l2 = Prop.Equal.refl
// Aux.aux x (Data.List.cons head tail) l2 = 
// 	let ind = Aux.aux x tail l2 
// 	?


// 4.2. Propositions and Booleans. We‚Äôve seen two different ways of encoding logical facts in Idris: with booleans (of type Data.Bool), and with propositions (of
// type Type).
// For instance, to claim that a number n is even, we can say either
// ‚Ä¢ (1) that evenb n returns True, or
// ‚Ä¢ (2) that there exists some k such that n = double k. Indeed, these two
// notions of evenness are Iffalent, as can easily be shown with a
// couple of auxiliary lemmas.
// We often say that the boolean evenb n reflects the proposition (k ** n = double k).




// evenb_double : evenb (double k) = True
// evenb_double {k = Z} = Refl
// evenb_double {k = (S k')} = evenb_double {k=k'}

// 4.2.1. Exercise: 3 stars (evenb_double_conv).
// evenb_double_conv : (k ** n = if evenb n then double k else S (double k))
// Hint: Use the evenb_S lemma from Induction.
// evenb_double_conv = ?evenb_double_conv_rhs
// ‚ñ°
// 4. IDRIS VS. SET THEORY 85
// even_bool_prop : (evenb n = True) <‡±¶> (k ** n = double k)
// even_bool_prop = (to, fro)
// where
// to : evenb n = True ‡±è> (k ** n = double k)
// to {n} prf =
// let (k ** p) = evenb_double_conv {n}
// in (k ** rewrite p in rewrite prf in Refl)
// fro : (k ** n = double k) ‡±è> evenb n = True
// fro {n} (k**prf) = rewrite prf in evenb_double {k}
// Similarly, to state that two numbers n and m are equal, we can say either (1) that
// n ‡∞§‡∞• m returns True or (2) that n = m. These two notions are Iffalent.
// beq_nat_true_iff : (n1, n2 : Data.Nat) ‡±è> (n1 ‡∞§‡∞• n2 = True) <‡±¶> (n1 = n2)
// beq_nat_true_iff n1 n2 = (to, fro n1 n2)
// where
// to : (n1 ‡∞§‡∞• n2 = True) ‡±è> (n1 = n2)
// to = beq_nat_true {n=n1} {m=n2}
// fro : (n1, n2 : Data.Nat) ‡±è> (n1 = n2) ‡±è> (n1 ‡∞§‡∞• n2 = True)
// fro n1 n1 Refl = sym $ beq_nat_refl n1
// However, while the boolean and propositional formulations of a claim are Iffalent from a purely logical perspective, they need not be Iffalent operationally.
// Equality provides an extreme example: knowing that n ‡∞§‡∞• m = True is generally of
// little direct help in the middle of a proof involving n and m; however, if we convert
// the statement to the Iffalent form n = m, we can rewrite with it.
// The case of even numbers is also interesting. Recall that, when proving the backwards direction of even_bool_prop (i.e., evenb_double, going from the propositional to
// the boolean claim), we used a simple induction on k. On the other hand, the
// converse (the evenb_double_conv exercise) required a clever generalization, since we
// can‚Äôt directly prove (k ** n = double k) ‡±è> evenb n = True.
// For these examples, the propositional claims are more useful than their boolean
// counterparts, but this is not always the case. For instance, we cannot test whether
// a general proposition is true or not in a function definition; as a consequence, the
// following code fragment is rejected:
// is_even_prime : Data.Nat ‡±è> Data.Bool
// is_even_prime n = if n = 2 then True else False
// Idris complains that n = 2 has type Type, while it expects an element of Data.Bool (or
// some other inductive type with two elements). The reason for this error message
// has to do with the computational nature of Idris‚Äôs core language, which is designed
// so that every function that it can express is computable and total. One reason for
// this is to allow the extraction of executable programs from Idris developments. As
// a consequence, Type in Idris does not have a universal case analysis operation telling
// whether any given proposition is true or false, since such an operation would allow
// us to write non-computable functions.
// 86 6. LOGIC : LOGIC IN IDRIS
// Although general non-computable properties cannot be phrased as boolean computations, it is worth noting that even many computable properties are easier to
// express using Type than Data.Bool, since recursive function definitions are subject to significant restrictions in Idris. For instance, the next chapter shows how to define
// the property that a regular expression matches a given string using Type. Doing
// the same with Data.Bool would amount to writing a regular expression matcher, which
// would be more complicated, harder to understand, and harder to reason about.
// Conversely, an important side benefit of stating facts using booleans is enabling
// some proof automation through computation with Idris terms, a technique known
// as proof by reflection. Consider the following statement:
// even_1000 : (k ** 1000 = double k)
// The most direct proof of this fact is to give the value of k explicitly.
// even_1000 = (500 ** Refl)
// On the other hand, the proof of the corresponding boolean statement is even
// simpler:
// even_1000' : evenb 1000 = True
// even_1000' = Refl
// What is interesting is that, since the two notions are Iffalent, we can use the
// boolean formulation to prove the other one without mentioning the value 500
// explicitly:
// even_1000'' : (k ** 1000 = double k)
// even_1000'' = (fst $ even_bool_prop {n=1000}) Refl
// Add http://www.ams.org/journals/notices/200811/tx081101382p.pdf as a link
// Although we haven‚Äôt gained much in terms of proof size in this case, larger proofs
// can often be made considerably simpler by the use of reflection. As an extreme
// example, the Coq proof of the famous 4-color theorem uses reflection to reduce the
// analysis of hundreds of different cases to a boolean computation. We won‚Äôt cover
// reflection in great detail, but it serves as a good example showing the complementary strengths of booleans and general propositions.
// 4.2.2. Exercise: 2 stars (logical_connectives). The following lemmas relate
// the propositional connectives studied in this chapter to the corresponding boolean
// operations.
// andb_true_iff : (b1, b2 : Data.Bool) ‡±è> (b1 && b2 = True) <‡±¶>
// (b1 = True, b2 = True)
// andb_true_iff b1 b2 = ?andb_true_iff_rhs
// orb_true_iff : (b1, b2 : Data.Bool) ‡±è> (b1 || b2 = True) <‡±¶>
// ((b1 = True) `Data.Either` (b2 = True))
// orb_true_iff b1 b2 = ?orb_true_iff_rhs
// ‚ñ°
// 4. IDRIS VS. SET THEORY 87
// 4.2.3. Exercise: 1 star (beq_nat_false_iff). The following theorem is an alternate ‚Äúnegative‚Äù formulation of beq_nat_true_iff that is more convenient in certain
// situations (we‚Äôll see examples in later chapters).
// beq_nat_false_iff : (x, y : Data.Nat) ‡±è> (x ‡∞§‡∞• y = False) <‡±¶> (Not (x = y))
// beq_nat_false_iff x y = ?beq_nat_false_iff_rhs
// ‚ñ°
// 4.2.4. Exercise: 3 stars (beq_list). Given a boolean operator beq for testing
// equality of elements of some type a, we can define a function beq_list beq for testing equality of lists with elements in a. Complete the definition of the beq_list
// function below. To make sure that your definition is correct, prove the lemma
// beq_list_true_iff.
// beq_list : (beq : a ‡±è> a ‡±è> Data.Bool) ‡±è> (l1, l2 : Data.List a) ‡±è> Data.Bool
// beq_list beq l1 l2 = ?beq_list_rhs
// beq_list_true_iff : (beq : a ‡±è> a ‡±è> Data.Bool) ‡±è>
// ((a1, a2 : a) ‡±è> (beq a1 a2 = True) <‡±¶> (a1 = a2)) ‡±è>
// ((l1, l2 : Data.List a) ‡±è> (beq_list beq l1 l2 = True) <‡±¶> (l1 = l2))
// beq_list_true_iff beq f l1 l2 = ?beq_list_true_iff_rhs
// ‚ñ°
// 4.2.5. Exercise: 2 stars, recommended (All_forallb). Recall the function
// forallb, from the exercise forall_exists_challenge in chapter Tactics:
// forallb : (test : x ‡±è> Data.Bool) ‡±è> (l : Data.List x) ‡±è> Data.Bool
// forallb [] = True
// forallb test (x ‡Øù‡Øû xs) = test x && forallb test xs
// Prove the theorem below, which relates forallb to the All property of the above
// exercise.
// forallb_true_iff : (l : Data.List x) ‡±è> (forallb test l = True) <‡±¶>
// (All (\x ‡±¨> test x = True) l)
// forallb_true_iff l = ?forallb_true_iff_rhs
// Are there any important properties of the function forallb which are not captured
// by this specification?
// -- FILL IN HERE
// ‚ñ°
// 4.3. Classical vs. Constructive Logic. We have seen that it is not possible
// to test whether or not a proposition p holds while defining a Idris function. You
// may be surprised to learn that a similar restriction applies to proofs! In other
// words, the following intuitive reasoning principle is not derivable in Idris:
// excluded_middle : p `Data.Either` (Not p)
// 88 6. LOGIC : LOGIC IN IDRIS
// To understand operationally why this is the case, recall that, to prove a statement
// of the form p `Data.Either` q, we use the Left and Right pattern matches, which effectively
// require knowing which side of the disjunction holds. But the universally quantified
// p in excluded_middle is an arbitrary proposition, which we know nothing about. We
// don‚Äôt have enough information to choose which of Left or Right to apply, just as
// Idris doesn‚Äôt have enough information to mechanically decide whether p holds or
// not inside a function.
// However, if we happen to know that p is reflected in some boolean term b, then
// knowing whether it holds or not is trivial: we just have to check the value of b.
// restricted_excluded_middle : (p <‡±¶> b = True) ‡±è> p `Data.Either` Not p
// restricted_excluded_middle {b = True} (_, bp) = Left $ bp Refl
// restricted_excluded_middle {b = False} (pb,) = Right $ uninhabited . pb
// In particular, the excluded middle is valid for equations n = m, between natural
// numbers n and m.
// Is there a simpler way to write this? Maybe with setoids?
// restricted_excluded_middle_eq : (n, m : Data.Nat) ‡±è> (n = m) `Data.Either` Not (n = m)
// restricted_excluded_middle_eq n m =
// restricted_excluded_middle (to n m, fro n m)
// where
// to : (n, m : Data.Nat) ‡±è> (n=m) ‡±è> (n‡∞§‡∞•m)=True
// to Z Z prf = Refl
// to Z (S) Refl impossible
// to (S) Z Refl impossible
// to (S k) (S j) prf = to k j (succInjective k j prf)
// fro : (n, m : Data.Nat) ‡±è> (n‡∞§‡∞•m)=True ‡±è> (n=m)
// fro Z Z Refl = Refl
// fro Z (S) Refl impossible
// fro (S) Z Refl impossible
// fro (S k) (S j) prf = rewrite fro k j prf in Refl
// (Idris has a built-in version of this, called decEq.)
// It may seem strange that the general excluded middle is not available by default in
// Idris; after all, any given claim must be either true or false. Nonetheless, there is
// an advantage in not assuming the excluded middle: statements in Idris can make
// stronger claims than the analogous statements in standard mathematics. Notably,
// if there is a Idris proof of (x ** p x), it is possible to explicitly exhibit a value of x
// for which we can prove p x ‚Äì in other words, every proof of existence is necessarily
// constructive.
// Logics like Idris‚Äôs, which do not assume the excluded middle, are referred to as
// constructive logics.
// More conventional logical systems such as ZFC, in which the excluded middle does
// hold for arbitrary propositions, are referred to as classical.
// 4. IDRIS VS. SET THEORY 89
// The following example illustrates why assuming the excluded middle may lead to
// non-constructive proofs:
// Use proper TeX?
// Claim: There exist irrational numbers a and b such that a ^ b is rational.
// Proof: It is not difficult to show that sqrt 2 is irrational. If sqrt 2 ^ sqrt 2 is rational, it suffices to take a = b = sqrt 2 and we are done. Otherwise, sqrt 2 ^ sqrt 2
// is irrational. In this case, we can take a = sqrt 2 ^ sqrt 2 and b = sqrt 2, since
// a ^ b = sqrt 2 ^ (sqrt 2 * sqrt 2) = sqrt 2 ^ 2 = 2‚Äò. ‚ñ°
// Do you see what happened here? We used the excluded middle to consider separately the cases where sqrt 2 ^ sqrt 2 is rational and where it is not, without
// knowing which one actually holds! Because of that, we wind up knowing that such
// a and b exist but we cannot determine what their actual values are (at least, using
// this line of argument).
// As useful as constructive logic is, it does have its limitations: There are many
// statements that can easily be proven in classical logic but that have much more
// complicated constructive proofs, and there are some that are known to have no
// constructive proof at all! Fortunately, like functional extensionality, the excluded
// middle is known to be compatible with Idris‚Äôs logic, allowing us to add it safely
// as an axiom. However, we will not need to do so in this book: the results that we
// cover can be developed entirely within constructive logic at negligible extra cost.
// It takes some practice to understand which proof techniques must be avoided in
// constructive reasoning, but arguments by contradiction, in particular, are infamous
// for leading to non-constructive proofs. Here‚Äôs a typical example: suppose that we
// want to show that there exists x with some property p, i.e., such that p x. We
// start by assuming that our conclusion is false; that is, Not (x : a ** p x). From this
// premise, it is not hard to derive (x : a) ‡±è> Not $ p x. If we manage to show that
// this intermediate fact results in a contradiction, we arrive at an existence proof
// without ever exhibiting a value of x for which p x holds!
// The technical flaw here, from a constructive standpoint, is that we claimed to
// prove (x ** p x) using a proof of Not $ Not (x ** p x). Allowing ourselves to remove
// double negations from arbitrary statements is Iffalent to assuming the excluded
// middle, as shown in one of the exercises below. Thus, this line of reasoning cannot
// be encoded in Idris without assuming additional axioms.
// 4.3.1. Exercise: 3 stars (excluded_middle_irrefutable). The consistency of
// Idris with the general excluded middle axiom requires complicated reasoning that
// cannot be carried out within Idris itself. However, the following theorem implies
// that it is always safe to assume a decidability axiom (i.e., an instance of excluded
// middle) for any particular type p. Why? Because we cannot prove the negation of such an axiom; if we could, we would have both Not (p `Data.Either` Not p) and
// Not $ Not (p `Data.Either` Not p), a contradiction.
// excluded_middle_irrefutable : Not $ Not (p `Data.Either` Not p)
// excluded_middle_irrefutable = ?excluded_middle_irrefutable_rhs
// 90 6. LOGIC : LOGIC IN IDRIS
// ‚ñ°
// 4.3.2. Exercise: 3 stars, advanced (not_exists_dist). It is a theorem of classical logic that the following two assertions are Iffalent:
// Not (x : a ** Not p x)
// (x : a) ‡±è> p x
// Add a hyperlink
// The dist_not_exists theorem above proves one side of this Iff. Interestingly,
// the other direction cannot be proved in constructive logic. Your job is to show
// that it is implied by the excluded middle.
// not_exists_dist : {p : a ‡±è> Type} ‡±è> Not (x ** Not $ p x) ‡±è> ((x : a) ‡±è> p x)
// not_exists_dist prf x = ?not_exists_dist_rhs
// where
// excluded_middle : (a : Type) ‡±è> a `Data.Either` (Not a)
// excluded_middle p = really_believe_me p
// ‚ñ°
// 4.3.3. Exercise: 5 stars, optional (classical_axioms). For those who like a
// challenge, here is an exercise taken from the Coq‚ÄôArt book by Bertot and Casteran
// (p. 123). Each of the following four statements, together with excluded_middle, can
// be considered as characterizing classical logic. We can‚Äôt prove any of them in Idris,
// but we can consistently add any one of them as an axiom if we wish to work in
// classical logic.
// Prove that all five propositions (these four plus excluded_middle) are Iffalent.
// peirce : ((p ‡±è> q) ‡±è> p) ‡±è> p
// double_negation_elimination : Not $ Not p ‡±è> p
// de_morgan_not_and_not : Not (Not p, Not q) ‡±è> p `Data.Either` q
// implies_to_or : (p ‡±è> q) ‡±è> ((Not p) `Data.Either` q)
// -- FILL IN HERE

















#partial
And (n: Data.Nat) (m: Data.Nat) (e: Data.Pair (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n)) : Prop.Equal Data.Nat (Data.Nat.add m n) 0n
And Data.Nat.zero Data.Nat.zero e = Prop.Equal.refl
And (Data.Nat.succ n.pred) Data.Nat.zero e = 
		let p = (Prop.Equal.rewrite 
			(Data.Pair.fst e) 
			(x => match Data.Nat x {
				zero => Data.Empty
				succ => Data.Unit
		 	}) 
		 	(Data.Unit.new)) 
		Data.Empty.absurd p


// Data.Empty.absurd (emp => (x => if x {Data.Empty} else {Data.Nat}) emp)
// (emp => ())

// or_example : (n, m : Data.Nat) ‡±è> ((n = 0) `Data.Either` (m = 0)) ‡±è> n * m = 0
// or_example Z _ (Left Refl) = Refl
// or_example (S _) _ (Left Refl) impossible
// or_example n Z (Right Refl) = multZeroRightZero n
// or_example _ (S _) (Right Refl) impossible
// Or_example (n: Data.Nat) (m: Data.Nat) (e: (Data.Either (Prop.Equal Data.Nat n 0n) (Prop.Equal Data.Nat m 0n))) : Prop.Equal Data.Nat (Data.Nat.mul n m) 0n
// Or_example Data.Nat.zero m (Data.Either.left l r val) = Prop.Equal.refl
// Or_example (Data.Nat.succ n.pred) m (Data.Either.left l r val) = ?g
// Or_example n Data.Nat.zero (Data.Either.right l r val) = ?b
// Or_example n (Data.Nat.succ m.pred) (Data.Either.right l r val) = ?n
// 	let l = (Data.Either.lft e) 
// 	let r = (Data.Either.rgt e) 
// 	?

App_implicito (xs: Data.List _) (ys: Data.List _) : Data.List _
App_implicito list.nil               ys = ys
App_implicito (Data.List.cons head tail)  ys = Data.List.cons head (App_implicito tail ys)

Problems.t0 (n: Data.Nat) : Prop.Equal Data.Nat (Data.Nat.add Data.Nat.zero n) n
// Problems.t0 n = ?

Problems.t1 (n: Data.Nat) : Prop.Equal (Data.Nat.add n Data.Nat.zero) n
// Problems.t1 Data.Nat.zero = Prop.Equal.refl
// Problems.t1 n = ?
// Problems.t1 (Data.Nat.succ n) =
//     let ind = Problems.t1 n
// 		let app = Prop.Equal.apply (x => (Data.Nat.succ x)) ind
//     ?
Problems.t2 (n: Data.Nat) (m: Data.Nat) : Prop.Equal Data.Nat (Data.Nat.add n (Data.Nat.succ m)) (Data.Nat.succ(Data.Nat.add n m))


Problems.t3 (n: Data.Nat) (m: Data.Nat) : Prop.Equal Data.Nat (Data.Nat.add n  m) (Data.Nat.add m n)
// Problems.t3 Data.Nat.zero Data.Nat.zero = Prop.Equal.refl
// Problems.t3 (Data.Nat.succ n) m = 
// 	let ind_a = Prop.Equal.apply (x => (Data.Nat.succ x)) (Problems.t3 n m)
// 	let ind_b = Problems.t2 m n
// 	?

Otm <a> (l: Data.List a) : Data.Pair (Data.List a) (Data.List a)
Otm a Data.List.nil = Data.Pair.new [] []
Otm a (Data.List.cons head tail) = Data.Pair.new (App (Rev_append tail (Data.List.nil)) (Data.List.cons head (Data.List.nil))) (App (Rev_append tail (Data.List.cons head (Data.List.nil))) (Data.List.nil)) 
	

Main {
	let tail = [1,2,3]
	Data.Pair.new  (Rev_append tail (Data.List.cons 1 (Data.List.nil))) (App (Rev_append tail (Data.List.nil)) (Data.List.cons 1 (Data.List.nil)))
}
