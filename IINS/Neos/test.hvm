
(List.bind xs f) = (List.flatten (List.map xs f))

(List.flatten []) = []
(List.flatten (List.cons head tail)) = (List.concat head (List.flatten tail))

(U60.if 0 t f) = f
(U60.if n t f) = t

(List.delete f []) = []
(List.delete f (List.cons head tail)) = (U60.if f [] (List.cons head (List.delete f tail)))

(List.concat [] ys) = ys
(List.concat (List.cons head tail) ys) = (List.cons head (List.concat tail ys))

(List.map [] f) = []
(List.map (List.cons head tail) f) = (List.cons (f head) (List.map tail f))

(List.length []) = 0
(List.length (List.cons head tail)) = (+ (List.length tail) 1)


// data BTree a = Leaf
//              | Node (BTree a) a (BTree a)


// insert x Leaf = Node Leaf x Leaf
// insert x (Node l v r) = if (x < v) then (Node (insert x l) v r)
//                                    else (Node l v (insert x r))


// toList Leaf = []
// toList (Node l v r) = Btree.toList l ++ (v :: Btree.toList r)


// toTree [] = Leaf
// toTree (x :: xs) = insert x (toTree xs)

(Main) = 
	let f = (String.cons 40 (String.cons 79 (String.cons 32 (String.cons 41 (String.cons 40 (String.cons 73 (String.cons 32 (String.cons 41 (String.cons 40 (String.cons 79 (String.cons 32 (String.cons 41 (String.concat (String.concat (String.concat Î»x0 x0 ")") ")") ")")))))))))))))
	f
	// Loto.list_result
