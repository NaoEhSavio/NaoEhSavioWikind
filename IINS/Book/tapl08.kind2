type Term { // metavariable
	true              // constant true
	false             // constant false
	zero              // constant zero
	succ (pred: Term) // successor
	pred (succ: Term) // predecessor
	iszr (zrts: Term) // zero test
	ifte (cond: Term) (then: Term) (else: Term) // conditional
}


Const (t: Term) : Data.List Term
Const (Term.zero) = [Term.zero]
Const (Term.succ pred) = Const pred
Const (Term.pred succ) = Const succ
Const (Term.iszr zt) = Const zt
Const (Term.true) = [Term.true]
Const (Term.false) = [Term.false]
Const (Term.ifte cond then else) = (Data.List.concat (Const cond) (Data.List.concat (Const then) (Const else)))

Size (t: Term) : Data.Nat
Size (Term.zero) = 1n
Size (Term.succ pred) = (Data.Nat.succ (Size pred))
Size (Term.pred succ) = (Data.Nat.succ (Size succ))
Size (Term.iszr zt) = (Data.Nat.succ (Size zt))
Size (Term.true) = 1n
Size (Term.false) = 1n
Size (Term.ifte cond then else) = (Data.Nat.succ (Data.Nat.add (Size cond) (Data.Nat.add (Size then) (Size else)))) 

Depth (t: Term) : Data.Nat
Depth (Term.zero) = 1n
Depth (Term.succ pred) = (Data.Nat.succ (Depth pred))
Depth (Term.pred succ) = (Data.Nat.succ (Depth succ))
Depth (Term.iszr zt) = (Data.Nat.succ (Depth zt))
Depth (Term.true) = 1n
Depth (Term.false) = 1n
Depth (Term.ifte cond then else) = (Data.Nat.succ (Data.Nat.max (Depth cond) (Data.Nat.max (Depth then) (Depth else))))

type Value { // Values
	true                // True Value
	false               // False Value
	nvalue (nv: Nvalue) // numeric value
	}
	
type Nvalue { // numeric values
	zero 								// zero value
	succ (pred: Nvalue) // successor value
}

type Ers ~(from: Term) (to: Term) { //Evaluation relation specification
	E_IfTrue <from: Term> <to: Term> : Ers (Term.ifte Term.true from to) from // (E-IfTrue) if true then t2 else t3 → t2
	E_IfFalse <from: Term> <to: Term> : Ers (Term.ifte Term.false from to) to // (E-IfFalse) if false then t2 else t3 → t3
	E_PredZero : Ers (Term.pred Term.zero) (Term.zero) // (E-PredZero) pred 0 → 0
	E_IsZeroZero : Ers (Term.iszr Term.zero) (Term.true) // (E-IsZeroZero) iszero 0 → true
	E_PredSucc <from: Term> : Ers (Term.pred (Term.succ from)) (from) // (E-PredSucc) pred ( succ nv1) → nv1
	E_IsZeroSucc <from: Term> : Ers (Term.iszr (Term.succ from)) (Term.false) // (E-IsZeroSucc) iszero ( succ nv1) → false
	E_Succ <from: Term> <to: Term> (s: Ers from to) : Ers (Term.succ from) (Term.succ to) // (E-Succ) t1 → t′1 //  succ t1 → succ t′1
	E_Pred <from: Term> <to: Term> (s: Ers from to) : Ers (Term.pred from) (Term.pred to) // (E-Pred) t1 → t′1 //pred t1 → pred t′1
	E_IsZero <from: Term> <to: Term> (s: Ers from to) : Ers (Term.iszr from) (Term.iszr to) // (E-IsZero) t1 → t′1 // iszero t1 → iszero t′1
	E_If <cond1: Term> <cond2: Term> <from: Term> <to: Term> (s: Ers cond1 cond2) : Ers (Term.ifte cond1 from to) (Term.ifte cond2 from to) // (E-If ) t1 → t′1 // if t1 then t2 else t3 → if t′1 then t2 else t3
}

type Types {
	Bool //type of booleans
	Nat  //type of booleans
}	

type Typed ~(t: Term) (tp: Types) {
	TTrue  : Typed Term.true  Types.Bool
	TFalse : Typed Term.false Types.Bool
	TZero  : Typed Term.zero  Types.Nat
	TSucc <pred: Term> (succ: Typed pred Types.Nat) : Typed (Term.succ pred) Types.Nat
	TPred <succ: Term> (pred: Typed succ Types.Nat) : Typed (Term.pred succ) Types.Nat
	TIsZero <test: Term> (zero: Typed test Types.Nat) : Typed (Term.iszr test) Types.Bool
	TIf <u: Types> <c: Term> <t: Term> <e: Term> (cond: Typed c Types.Bool) (then: Typed t u) (else: Typed e u) : Typed (Term.ifte c t e) u
}

// Evaluation (t: Term) : Term 
// Evaluation (Term.ifte Term.true then else) = then // E-iftrue
// Evaluation (Term.ifte Term.false then else) = else // E-ifflase
// Evaluation (Term.ifte cond then else) = Term.ifte (Evaluation cond) then else // E-if
// Evaluation (Term.succ pred) = Term.succ (Evaluation pred) // E-Succ
// Evaluation (Term.pred Term.zero) = Term.zero // (E-PredZero)
// Evaluation (Term.pred (Term.succ succpred)) = succpred // E-PredSucc
// Evaluation (Term.pred succ) = Term.pred (Evaluation succ) // E-Pred
// Evaluation (Term.iszr Term.zero) = Term.true // (E-IszeroZero)
// Evaluation (Term.iszr (Term.succ ztpred)) = Term.false // E-IszeroSucc
// Evaluation (Term.iszr zt) = Term.iszr (Evaluation zt) // E-IsZero)
// Evaluation t = t // zero, true, false

Evaluation (t: Term) : Data.Maybe Term 
Evaluation (Term.ifte Term.true then else) = Data.Maybe.some then // E-iftrue
Evaluation (Term.ifte Term.false then else) = Data.Maybe.some else // E-ifflase
Evaluation (Term.ifte cond then else) = 
	let cond = (Evaluation cond)
	match Data.Maybe cond {
		none => Data.Maybe.none
		some value => Data.Maybe.some (Term.ifte value then else) // E-If
	}
Evaluation (Term.succ pred) = 
	let cond = (Evaluation pred)
	match Data.Maybe cond {
		none => Data.Maybe.none
		some value => Data.Maybe.some (Term.succ value) // E-Succ
	}
Evaluation (Term.pred Term.zero) = Data.Maybe.some (Term.zero) // E-PredZero
Evaluation (Term.pred (Term.succ succpred)) = Data.Maybe.some (succpred) // E-PredSucc
Evaluation (Term.pred succ) = 
	let cond = (Evaluation succ)
	match Data.Maybe cond {
		none => Data.Maybe.none
		some value => Data.Maybe.some (Term.pred value) // E-Pred
	}
Evaluation (Term.iszr Term.zero) = Data.Maybe.some (Term.true) // E-IszeroZero
Evaluation (Term.iszr (Term.succ ztpred)) = Data.Maybe.some (Term.false) // E-IszeroSucc
Evaluation (Term.iszr zt) = 
	let cond = (Evaluation zt)
	match Data.Maybe cond {
		none => Data.Maybe.none
		some value => Data.Maybe.some (Term.iszr value) // E-IsZero
	}
Evaluation Term.zero = Data.Maybe.some Term.zero // zero
Evaluation Term.true = Data.Maybe.some Term.true // true
Evaluation Term.false = Data.Maybe.some Term.false // flase
Evaluation t = Data.Maybe.none // Not Value

// Evaluation <t: Types> (term: Term) (tp: Typed term t) : Term 
// Evaluation t (Term.ifte Term.true then else) tp = then // E-iftrue
// Evaluation t (Term.ifte Term.false then else) tp = else // E-ifflase
// Evaluation t (Term.ifte cond then else) (Typed.TIf cond1 then2 else3) = Term.ifte (Evaluation cond cond1) then else // E-if
// Evaluation t (Term.succ pred) (Typed.TSucc pred1)= Term.succ (Evaluation pred pred1) // E-Succ
// Evaluation t (Term.pred Term.zero) tp = Term.zero // (E-PredZero)
// Evaluation t (Term.pred (Term.succ succpred)) (Typed.TPred (Typed.TSucc succpred1)) = succpred // E-PredSucc
// Evaluation t (Term.pred succ) (Typed.TPred succ1) = Term.pred (Evaluation succ succ1) // E-Pred
// Evaluation t (Term.iszr Term.zero) tp = Term.true // (E-IszeroZero)
// Evaluation t (Term.iszr (Term.succ zeropred)) (Typed.TIsZero (Typed.TSucc zeropred1)) = Term.false // E-IszeroSucc
// Evaluation t (Term.iszr zero) (Typed.TIsZero zero1)= Term.iszr (Evaluation zero zero1) // E-IsZero)
// Evaluation t Term.true tp = Term.true // true
// Evaluation t Term.false tp = Term.false // false
// Evaluation t Term.zero tp = Term.zero // zero
// Evaluation t (Term.iszr Term.true) tp = ? // Not Value

// 8.2.2 Lemma [Inversion of the typing relation]:
// 1. If true : R, then R = Bool.
Lemma8221 <r: Types> (tp: Typed Term.true r) : Prop.Equal r Types.Bool
Lemma8221 r (Typed.TTrue) = Prop.Equal.refl
// 2. If false : R, then R = Bool.
Lemma8222 <r: Types> (tp: Typed Term.false r) : Prop.Equal r Types.Bool
Lemma8222 r (Typed.TFalse) = Prop.Equal.refl
// 3. If if t1 then t2 else t3 : R, then t1 : Bool, t2 : R, and t3 : R.
Lemma8223 <r: Types> <c: Term> <t: Term> <e: Term> (tp: Typed (Term.ifte c t e) r) : Data.Pair (Typed c Types.Bool) (Data.Pair (Typed t r) (Typed e r))
Lemma8223 r c t e (Typed.TIf s d u f cond then else) = Data.Pair.new cond (Data.Pair.new then else)
// 4. If 0 : R, then R = Nat.
Lemma8224 <r: Types> (tp: Typed Term.zero r) : Prop.Equal r Types.Nat
Lemma8224 r (Typed.TZero) = Prop.Equal.refl
// 5. If succ t1 : R, then R = Nat and t1 : Nat.
Lemma8225 <r: Types> <pred: Term> (tp: Typed (Term.succ pred) r) : Data.Pair (Prop.Equal r Types.Nat) (Typed pred Types.Nat)
Lemma8225 r pred (Typed.TSucc pred1 succ) = Data.Pair.new (Prop.Equal.refl) succ
// 6. If pred t1 : R, then R = Nat and t1 : Nat.
Lemma8226 <r: Types> <succ: Term> (tp: Typed (Term.pred succ) r) : Data.Pair (Prop.Equal r Types.Nat) (Typed succ Types.Nat)
Lemma8226 r succ (Typed.TPred succ1 pred) = Data.Pair.new (Prop.Equal.refl) pred
// 7. If iszero t1 : R, then R = Bool and t1 : Nat. 
Lemma8227 <r: Types> <zero: Term> (tp: Typed (Term.iszr zero) r) : Data.Pair (Prop.Equal r Types.Bool) (Typed zero Types.Nat)
Lemma8227 r zero (Typed.TIsZero zero1 test) = Data.Pair.new (Prop.Equal.refl) test

// 8.2.3 Exercise : Prove that every subterm of a well-typed term is well typed.

type Subterm ~(term: Term) (subterm: Term) {
	refl <term: Term> : Subterm term term
	succ <term: Term> <subterm: Term> (pred: Subterm term subterm): Subterm (Term.succ term) subterm
	pred <term: Term> <subterm: Term> (succ: Subterm term subterm): Subterm (Term.pred term) subterm
	iszr <term: Term> <subterm: Term> (zero: Subterm term subterm): Subterm (Term.iszr term) subterm
	ifte <term: Term> <then: Term> <else: Term> <subterm: Term> (cond: Subterm term subterm): Subterm (Term.ifte term then else) subterm
	iftt <term: Term> <then: Term> <else: Term> <subterm: Term> (then1: Subterm then subterm): Subterm (Term.ifte term then else) subterm
	ifee <term: Term> <then: Term> <else: Term> <subterm: Term> (else1: Subterm else subterm): Subterm (Term.ifte term then else) subterm
}


Exercise823 <term: Term> <ty: Types> (tp: Typed term ty) (subterm: Term) (st: Subterm term subterm): Typed subterm ty
Exercise823 term ty (Typed.TZero) Term.zero (Subterm.refl t) = Typed.TZero
Exercise823 term ty (Typed.TTrue) Term.true (Subterm.refl t) = Typed.TTrue
Exercise823 term ty (Typed.TFalse) Term.false (Subterm.refl t) = Typed.TFalse
Exercise823 (Term.succ term)  ty (Typed.TSucc succ pred) s (Subterm.succ term1 succ1 pred1) = 
	let ind = Exercise823 pred s pred1 
	ind
Exercise823 (Term.pred term) ty (Typed.TPred succ pred) s (Subterm.pred term1 succ1 pred1) = 
	let ind = Exercise823 pred s pred1 
	ind
Exercise823 (Term.iszr term) ty (Typed.TIsZero zero test) s (Subterm.iszr term1 zero1 test1) = 
	let ind = Exercise823 test s test1
	// let aux = Lemma8227 (Typed.TIsZero term test)
	let auy = Subterm.iszr term s test1
	// let ine = Exercise823 ? s auy
	let auz = Typed.TIsZero test
// Exercise823 term Types.Bool (Typed.TIsZero zero test) s (Subterm.refl r) = 
	// let e0  = Prop.Equal.refl :: term (Term.iszr zero)
	// let auz = Typed.TIsZero test
	?

Exercise823 (Term.ifte cd th el) ty (Typed.TIf u c t e cond then else ) s (Subterm.refl r) =
	let ok = (Typed.TIf u c t e cond then else)
	let e0 = Prop.Equal.refl :: Prop.Equal u ty
	let e1 = Prop.Equal.refl :: Prop.Equal c cd 
	let e2 = Prop.Equal.refl :: Prop.Equal t th
	let e3 = Prop.Equal.refl :: Prop.Equal e el
	let e4 = Prop.Equal.refl :: Prop.Equal r s
	let e5 = Prop.Equal.refl :: Prop.Equal (Term.ifte cd th el) r
	let chn = Prop.Equal.chain e5 e4
	let rrt = Prop.Equal.rewrite e0 (x => (Typed (Term.ifte c t e) x)) ok
	let rru = Prop.Equal.rewrite e1 (x => (Typed (Term.ifte x t e) ty)) rrt
	let rrv = Prop.Equal.rewrite e2 (x => (Typed (Term.ifte cd x e) ty)) rru
	let rrw = Prop.Equal.rewrite e3 (x => (Typed (Term.ifte cd th x) ty)) rrv
	let rrx = Prop.Equal.rewrite chn (x => (Typed x ty)) rrw
	rrx
Exercise823 (Term.ifte cd th el) ty (Typed.TIf u c t e cond then else ) s (Subterm.iftt d r f v cond1) = 
	let ind = Exercise823 then s cond1
	ind
Exercise823 (Term.ifte cd th el) ty (Typed.TIf u c t e cond then else ) s (Subterm.ifee d r f v cond1) = 
	let ind = Exercise823 else s cond1
	ind






// theoremSubtermTyping : {t : Term} -> {ty : Type} -> Typing t ty -> (subterm : Term) -> Typing subterm ty
// theoremSubtermTyping (T_Var) _ = T_Var
// theoremSubtermTyping (T_True) _ = T_True
// theoremSubtermTyping (T_False) _ = T_False
// theoremSubtermTyping (T_If t1 t2 t3) subterm =
//   case subterm of
//     Var => T_Var
//     True => T_True
//     False => T_False
//     If subterm1 subterm2 subterm3 =>
//       T_If (theoremSubtermTyping t1 subterm1)
//            (theoremSubtermTyping t2 subterm2)
//            (theoremSubtermTyping t3 subterm3)