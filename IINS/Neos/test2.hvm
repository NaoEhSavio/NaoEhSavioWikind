(List.map [] f) = []
(List.map (List.cons head tail) f) = (List.cons (f head) (List.map tail f))

(List.concat [] ys) = ys
(List.concat (List.cons head tail) ys) = (List.cons head (List.concat tail ys))

(List.length []) = 0
(List.length (List.cons head tail)) = (+ 1 (List.length tail))

(U60.if 0 t f) = f
(U60.if n t f) = t
(List.delete_all v (List.nil)) = (List.nil)
(List.delete_all v (List.cons head tail)) = (Bool.if (U60.equal v head) (List.delete_all v tail) (List.cons head (List.delete_all v tail)))
(U60.to_bool 0) = (Bool.false)
(U60.to_bool n) = (Bool.true)

// U60.equal (a: U60) (b: U60) : (Bool)
(U60.equal a b) = (U60.to_bool (== a b))

// Bool.if -(a: Type) (b: (Bool)) (t: a) (f: a) : a
(Bool.if (Bool.true) t f) = t
(Bool.if (Bool.false) t f) = f

// List.u60.filter.go (cond: (_: U60) U60) (eql: U60) (xs: (List U60)) : (List U60)
(List.u60.filter.go cond eql (List.nil)) = (List.nil)
(List.u60.filter.go cond 0 (List.cons head tail)) = (List.u60.filter.go cond (cond head) tail)
(List.u60.filter.go cond 1 (List.cons head tail)) = (List.cons head (List.u60.filter.go cond (cond head) tail))

// List.u60.filter (cond: (_: U60) U60) (xs: (List U60)) : (List U60)
(List.u60.filter cond (List.nil)) = (List.nil)
(List.u60.filter cond (List.cons head tail)) = 
let eql = (cond head); 
(List.u60.filter.go cond eql (List.cons head tail))

(Sum (List.nil))       = 0 //                     314053713
(Sum (List.cons x xs)) = (+ x (Sum xs))

// Loto (xs: (List (List U60))) : (List U60)
(Loto (List.nil)) = (List.nil)
(Loto (List.cons head tail)) = let h = (Sum head); let t = (Loto tail); (List.cons h t)

// Porcent (xs: (List U60)) : (List (List U60))
(Porcent xs) = (Porcent.go xs (List.length xs))

// Porcent.go (xs: (List U60)) (len: U60) : (List (List U60))
(Porcent.go [] len) = []
(Porcent.go (List.cons head tail) len) = 
	let eql = (List.length (List.u60.filter @a (== head a) (List.cons head tail) )); 
	let par = (List.cons head [eql]); 
	let del = (List.delete_all head (List.cons head tail)); 
	let res = (Porcent.go del len); 
	(List.cons par res)


// def combinations(lst, k):
//     if k == 0:
//         return [[]]
//     elif len(lst) == 0:
//         return []
//     elif len(lst) < k:
//         return []
//     else:
//         elem = lst[0]
//         rest = lst[1:]
//         combs_without_elem = combinations(rest, k)
//         combs_with_elem = combinations(rest, k-1)
//         combs_with_elem = map(lambda x: [elem]+x, combs_with_elem)
//         return list(combs_without_elem) + list(combs_with_elem)

(COMB [] k) = []
(COMB (List.cons head tail) k) = (
	let len = ( (List.length tail)); 
	(U60.if (== k 0) ([[]]) (
		(U60.if (== len 0) ([]) (
			(U60.if (< len k) ([]) (
				let hd = (COMB tail k);
				let tl = (COMB tail (- k 1));
				let mp = (List.map tl (@x (List.cons head x))); 
				(List.concat mp hd)
			)
		)	
	)
))))

// (COMB.GO [] k acum) = [acum]
// (COMB.GO (List.cons head tail) k acum) = (
// 	let len = (+ 1 (List.length tail)); 
// 	(U60.if (| (| (== k 0)(== len 0)) (< len k)) (acum) (
// 		let hd = (COMB.GO tail k acum);
// 		let tl = (COMB.GO tail (- k 1) acum);
// 		let mp = (List.map tl (@x (List.concat [head] x))); 
// 		(List.cons [acum] (List.concat hd mp))
// 		)
// 	)	
// )
 
// Strict constructors
(Cons !a !b) = (List.cons a b)


// (Main) = (List.length (Comb [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))
// (Main) = (List.length (COMB [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26] 15))
(Main) = (((COMB [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0] 15)))
// (Main) = (List.length  (COMB [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0] 15))