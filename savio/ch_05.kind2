// 1.1. Polymorphic Lists.
// data BoolList : Type where
// BoolNil : BoolList
// BoolCons : Bool ౏> BoolList ౏> BoolList
BoolList : Type
BoolList = (List Bool)

// Data List : (x : Type) ౏> Type where
// Nil : List x
// Cons : x ౏> List x ౏> List x
List <a: Type> : Type
List.nil <a> : List a  
List.cons <a> (head: a) (tail: List a) : List a  

// repeat : (x_ty : Type) ౏> (x : x_ty) ౏> (count : Nat) ౏> List x_ty
// repeat x_ty x Z = Nil
// repeat x_ty x (S count') = x ௝௞ repeat x_ty x count'
Repeat <x_ty: Type> (x: x_ty) (count: Nat) : List x_ty
Repeat x_ty x Nat.zero = (List.nil x_ty)
Repeat x_ty x (Nat.succ count) = List.cons x (Repeat x_ty x count)

// test_repeat1 : repeat Nat 4 2 = 4 ௝௞ (4 ௝௞ Nil)
// test_repeat1 = Refl
Test_repeat1 : Equal (Repeat Nat (U60.to_nat 4) (U60.to_nat 2)) (List.cons (U60.to_nat 4) (List.cons (U60.to_nat 4) (List.nil Nat)))
Test_repeat1 = Equal.refl

// test_repeat2 : repeat Bool False 1 = False ௝௞ Nil
// test_repeat2 = Refl
Test_repeat2 : Equal BoolList (Repeat Bool (Bool.false) (U60.to_nat 1)) (List.cons (Bool.false) (List.nil Bool))
Test_repeat2 = Equal.refl

// 1.1.1. Exercise: 2 stars (mumble_grumble).
// Explain implicits and {x=foo} syntax first? Move after the ”Supplying Type
// Arguments Explicitly” section?
// namespace MumbleGrumble
// Consider the following two inductively defined types.
// data Mumble : Type where
// A : Mumble
// B : Mumble ౏> Nat ౏> Mumble
// C : Mumble
// data Grumble : (x : Type) ౏> Type where
// D : Mumble ౏> Grumble x
// E : x ౏> Grumble x
// Which of the following are well-typed elements of Grumble x for some type x?
// • D (B A 5)
// • D (B A 5) {x=Mumble}
// • D (B A 5) {x=Bool}
// • E True {x=Bool}
// • E (B C 0) {x=Mumble}
// • E (B C 0) {x=Bool}
// • C
// -- FILL IN HERE

// 1.1.4. Implicit Arguments


App <a> (l1: List a) (l2: List a) : List a
App (List.nil ) l2 = l2
App (List.cons x head tail) l2 = List.cons head (App tail l2) 

Rev <x> (l: List x) : List x
Rev List.nil = List.nil                                         // #######[head]#######
Rev (List.cons x head tail) = App (Rev tail) (List.cons head List.nil) 


Length <x> (l: List x) : Nat
Length List.nil = Nat.zero
Length (List.cons x head tail) = Nat.succ (Length tail)
// test_rev1 : rev (1௝௞2௝௞List.nil) = 2௝௞1௝௞List.nil
// test_rev1 = Refl
Test_rev1 : Equal (Rev (List.nil)) (List.nil)
Test_rev1 = Equal.refl
// test_rev2 : rev (True௝௞List.nil) = True௝௞List.nil
// test_rev2 = Refl
Test_rev2 : Equal (Rev (List.nil)) (List.nil)
Test_rev2 = Equal.refl
// test_length1 : length (1௝௞2௝௞3௝௞List.nil) = 3
// test_length1 = Refl
Test_length1 : Equal (Length (List.nil)) (Nat.zero)
Test_length1 = Equal.refl
// 1.1.6. Exercise: 2 stars, optional (poly_exercises). Here are a few simple exercises, just like ones in the Lists chapter, for practice with polymorphism. Complete
// the proofs below.
// app_nil_r : (l : List x) ౏> l ++ List.nil = l
// app_nil_r l = ?app_nil_r_rhs
App_nil_r <x> (l: List x) : (Equal (App l List.nil) l)

// app_assoc : (l, m, n : List a) ౏> l ++ m ++ n = (l ++ m) ++ n
// app_assoc l m n = ?app_assoc_rhs
App_assoc <a> (l: List a) (m: List a) (n: List a) : (Equal (App l (App m n)) (App (App l m) n)) 

// app_length : (l1, l2 : List x) ౏> length (l1 ++ l2) = length l1 + length l2
// app_length l1 l2 = ?app_length_rhs
App_length <x> (l1: List x) (l2: List x) : (Equal Nat (Length (App l1 l2)) (Nat.add (Length l1) (Length l2)))

// 1.1.7. Exercise: 2 stars, optional (more_poly_exercises). Here are some slightly more interesting ones…
// rev_app_distr : (l1, l2 : List x) ౏> rev (l1 ++ l2) = rev l2 ++ rev l1
// rev_app_distr l1 l2 = ?rev_app_distr_rhs
Rev_app_distr <x> (l1: List x) (l2: List x) : (Equal (List x) (Rev (App l1 l2)) (App (Rev l2) (Rev l1)))



// - Goal  : (Equal (List a0_) (App _ (Rev _ (App _ xs l2)) (List.cons _ x (List.nil _))) (App _ (Rev x1_ l2) (App _ (Rev _ xs) (List.cons _ x (List.nil _)))))
// rev_involutive : (l : List x) ౏> rev (rev l) = l
// rev_involutive l = ?rev_involutive_rhs
Rev_involutive <x> (l: List x) : (Equal (Rev (Rev l)) l)

// 1.2. Polymorphic Pairs. Following the same pattern, the type definition
// we gave in the last chapter for pairs of numbers can be generalized to polymorphic
// pairs, often called products:
// Prod (x) (y) : Type
// Prod x y = Pair x y 
// Prod +<x> +<y> : Type
// Prod = Pair x y
// // Pair x y 
// Pair (x) (y) : Type
// Pair.new <x> <y> (fst: x) (snd: y) : (Pair x y)

Fst <x> <y> (pair: Pair x y) : x
Fst (Pair.new pair.x pair.y fst snd) = fst

// Fst <a> <b> (pair: Pair a b) : a
// Fst a b (Pair.new p.a p.b fst snd) = fst

Snd <x> <y> (p: Pair x y) : y
Snd (Pair.new pair.x pair.y fst snd) = snd

// // zip : (lx : List x) ౏> (ly : List y) ౏> List (x*y)
// // zip List.nil _ = List.nil
// // zip _ List.nil = List.nil
// // zip (x௝௞tx) (y௝௞ty) = (x,y) ௝௞ zip tx ty
Zip <x> <y> (lx: List x) (ly: List y) : (List (Pair x y))
Zip List.nil ly = List.nil
Zip lx List.nil = List.nil
Zip (List.cons lx lx.head lx.tail) (List.cons ly ly.head ly.tail) = List.cons (Pair.new lx.head ly.head) (Zip lx.tail ly.tail)

// 1.2.1. Exercise: 1 star, optional (combine_checks). Try answering the following questions on paper and checking your answers in Idris:
// • What is the type of zip (i.e., what does :t zip print?)
// • What does combine [1,2] [False,False,True,True] print?

// 1.2.2. Exercise: 2 stars, recommended (split). The function split is the right
// inverse of zip: it takes a list of pairs and returns a pair of lists. In many functional
// languages, it is called unzip.

// Fill in the definition of split below. Make sure it passes the given unit test.

// split : (l : List (x*y)) ౏> (List x) * (List y)
// split l = ?split_rhs
Split <x> <y> (l: List (Pair x y)) : Pair (List x) (List y)
Split x y List.nil = Pair.new List.nil List.nil
Split x y (List.cons l pair tail) = 
  let res = Split tail
  let fst = Fst pair
  let snd = Snd pair
  Pair.match res (a => (Pair (List x) (List y))) (res.fst => res.snd => (Pair.new (List.cons fst res.fst) (List.cons snd res.snd)))

Test_split : (Equal (Pair (List U60) (List Bool)) (Split [(Pair.new 1 Bool.false),(Pair.new 2 Bool.false)]) (Pair.new [1,2] [Bool.false,Bool.false]))
Test_split = Equal.refl
// □
// 1.2.3. Polymorphic Options. One last polymorphic type for now: polymorphic
// options, which generalize NatOption from the previous chapter:
Option (x) : Type
Option x = Maybe x 
//  Maybe x

// In Idris’ standard library this type is called Maybe, with constructors Just x and
// Nothing.
// We can now rewrite the nth_error function so that it works with any type of lists.

Nth_error <x> (l: List x) (n: Nat) : Option x
Nth_error x List.nil n = (Maybe.none x)
Nth_error x (List.cons l head tail) Nat.zero = Maybe.some head
Nth_error x (List.cons l head tail) (Nat.succ n) = Nth_error tail n

// test_nth_error1 : nth_error [4,5,6,7] 0 = Some 4
// test_nth_error1 = Refl

// test_nth_error2 : nth_error [[1],[2]] 1 = Some [2]
// test_nth_error2 = Refl

// test_nth_error3 : nth_error [True] 2 = None
// test_nth_error3 = Refl

// 1.2.4. Exercise: 1 star, optional (hd_error_poly). Complete the definition of
// a polymorphic version of the hd_error function from the last chapter. Be sure that
// it passes the unit tests below.

// hd_error : (l : List x) ౏> Option x
// hd_error l = ?hd_error_rhs
Hd_error <x> (l: List x) :  Option x
Hd_error x (List.nil l) = (Maybe.none x)
Hd_error x (List.cons l head tail) = (Maybe.some head)

// test_hd_error1 : hd_error [1,2] = Some 1
// test_hd_error1 = ?test_hd_error1_rhs

// test_hd_error2 : hd_error [[1],[2]] = Some [1]
// test_hd_error2 = ?test_hd_error2_rhs

// 2. Functions as Data
// 2.1. Higher-Order Functions. Functions that manipulate other functions
// are often called higher-order functions. Here’s a simple one:
// doit3times : (f: x ౏> x) ౏> (n : x) ౏> x
// doit3times f n = f (f (f n))
Doit3times <x> (func: x -> x) (n: x) : x
Doit3times x func n = (func (func (func n)))


Numbers.minusTwo (n: Nat) : Nat
Numbers.minusTwo Nat.zero = Nat.zero
Numbers.minusTwo (Nat.succ Nat.zero) = Nat.zero
Numbers.minusTwo (Nat.succ (Nat.succ k)) = k

// test_doit3times : doit3times Numbers.minusTwo 9 = 3
// test_doit3times = Refl
Test_doit3times : (Equal (Doit3times (x => Numbers.minusTwo x) (U60.to_nat 9)) (U60.to_nat 3))
Test_doit3times = Equal.refl

// test_doit3times' : doit3times Bool.not True = False
// test_doit3times' = Refl
Test_doit3times2 : (Equal (Doit3times (x => Bool.not x) Bool.true) Bool.false)
Test_doit3times2 = Equal.refl
// - Goal: (Equal _ Bool.false Bool.false)
// 2.2. Filter. Here is a more useful higher-order function, taking a list of xs
// and a predicate on x (a function from x to Bool) and “filtering” the list, returning
// a new list containing just those elements for which the predicate returns True.


Filter <x> (test: x -> Bool) (l: (List x)) : (List x)
Filter x test (List.nil l) = (List.nil)
Filter x test (List.cons l head tail) = 
  Bool.match (test head) ( x => _ ) (List.cons head (Filter test tail)) (Filter test tail)
    // if (func head) {List.cons head (Filter func tail)}
    //     else {Filter func tail}

// (This is how it’s defined in Idris’s stdlib, too.)
// For example, if we apply filter to the predicate evenb and a list of numbers l, it
// returns a list containing just the even members of l.

// test_filter1 : filter Numbers.evenb [1,2,3,4] = [2,4]
// test_filter1 = Refl

// length_is_1 : (l: List x) ౏> Bool
// length_is_1 l = length l తథ 1
Length_is_1 <x> (l: List x ) : Bool
Length_is_1 l = Nat.equal (Length l) (Nat.succ Nat.zero)

// test_filter2 : filter Poly.length_is_1 [ [1,2], [3], [4], [5,6,7], List.nil, [8] ] = [ [3], [4], [8] ] 
// test_filter2 = Refl
Nat.odd (n: Nat) : Bool
Nat.odd Nat.zero = Bool.false
Nat.odd (Nat.succ Nat.zero) = Bool.true
Nat.odd (Nat.succ (Nat.succ k)) = Nat.odd k

// countoddmembers' : (l: List Nat) ౏> Nat
// countoddmembers' l = length (filter Numbers.oddb l)
Countoddmembers (l: List Nat) : Nat
Countoddmembers l = Length (Filter (x => Nat.odd x) l)

// test_countoddmembers'1 : countoddmembers' [1,0,3,1,4,5] = 4
// test_countoddmembers'1 = Refl

// test_countoddmembers'2 : countoddmembers' [0,2,4] = 0
// test_countoddmembers'2 = Refl

// test_countoddmembers'3 : countoddmembers' Nil = 0
// test_countoddmembers'3 = Refl

// 2.3. Anonymous Functions. 
// test_anon_fun' : doit3times (\n ౬> mult n n) 2 = 256
// test_anon_fun' = Refl

// The expression \n ౬> mult n n can be read as “the function that, given a number n,
// yields n * n.”
// Here is the filter example, rewritten to use an anonymous function.

// test_filter2' : filter (\l ౬> length l తథ 1)
// [ [1,2], [3], [4], [5,6,7], List.nil, [8] ]
// = [ [3], [4], [8] ]
// test_filter2' = Refl

// 2.3.1. Exercise: 2 stars (filter_even_gt7). Use filter (instead of function definition) to write an Idris function filter_even_gt7 that takes a list of natural numbers
// as input and returns a list of just those that are even and greater than 7.

List.filter_even_gt7 (l: List U60) : List U60 {
  Filter (x => (Bool.and (U60.to_bool (> x 7)) (U60.to_bool (== 0 (% x 2))))) l
}
// List.filter_even_gt7 (l: List Nat) : List Nat
// List.filter_even_gt7 List.nil = List.nil 
// List.filter_even_gt7 (List.cons l head tail) = 
//   // let eve = Filter (x => Nat.is_even x) (List.cons l head tail)
//   let gt7 = Filter (x => (Nat.gtn x (U60.to_nat 7))) (List.cons l head tail)
//   gt7

Test_filter_even_gt7_1 : (Equal (List.filter_even_gt7 [1,2,6,9,10,3,12,8]) ([10,12,8]))
Test_filter_even_gt7_1 = Equal.refl

// test_filter_even_gt7_2 : filter_even_gt7 [5,2,6,19,129] = List.nil
// test_filter_even_gt7_2 = ?test_filter_even_gt7_2_rhs

// 2.3.2. Exercise: 3 stars (partition). Use filter to write an Idris function partition:
Partition <x> (test: x -> Bool) (l : List x) : Pair (List x) (List x)
Partition test List.nil = Pair.new List.nil List.nil
Partition test (List.cons head tail) =
  let t = Filter (x => test x) (List.cons head tail)
  let f = Filter (x => Bool.not(test x)) (List.cons head tail)
  Pair.new t f
// partition f xs = ?partition_rhs

// Given a set x, a test function of type x ౏> Bool and a partitionList x, partition should return a
// pair of lists. The first member of the pair is the sublist of the original list containing
// the elements that satisfy the test, and the second is the sublist containing those
// that fail the test. The order of elements in the two sublists should be the same as
// their order in the original list.

Test_partition1 : (Equal (Partition (x => Nat.odd (U60.to_nat x)) [1,2,3,4,5])  (Pair.new [1,3,5] [2,4]))
Test_partition1 = Equal.refl

Test_partition2 : (Equal (Partition (x => Bool.false) [5,9,0]) (Pair.new List.nil [5,9,0]))
Test_partition2 = Equal.refl

// 2.4. Map. Another handy higher-order function is called map.

Map <x> <y> (func: x -> y) (l: (List x)): (List y)
Map func List.nil = List.nil
Map func (List.cons head tail) = List.cons (func head) (Map func tail)

// It takes a function f and a list l = [n1, n2, n3, ...] and returns the list
// [f n1, f n2, f n3,...], where f has been applied to each element of l in turn. For
// example:

Test_map1 : Equal (Map (x => (+ 3 x)) [2,0,2]) [5,3,5]
Test_map1 = Equal.refl

// The element types of the input and output lists need not be the same, since map
// takes two type arguments, x and y; it can thus be applied to a list of numbers and
// a function from numbers to booleans to yield a list of booleans

// test_map2 : map Numbers.oddb [2,1,2,5] = [False,True,False,True]
// test_map2 = Refl

// It can even be applied to a list of numbers and a function from numbers to lists
// of booleans to yield a list of lists of booleans:

// test_map3 : map (\n ౬> [evenb n, oddb n]) [2,1,2,5]
// = [[True,False],[False,True],[True,False],[False,True]]
// test_map3 = Refl

// 2.4.1. Exercise: 3 stars (map_rev). Show that map and rev commute. You may
// need to define an auxiliary lemma.
// map_rev : (f : x ౏> y) ౏> (l : List x) ౏> map f (rev l) = rev (map f l)
// map_rev f l = ?map_rev_rhs

List.map_app <x> <y> (func: x -> y) (xs: (List x)) (ys: (List x)) : Equal (Map func (App xs ys)) (App (Map func xs) (Map func ys)) 




List.map_rev <x> <y> (func: x -> y) (l: (List x)) : Equal (Map func (Rev l)) (Rev (Map func l))  
List.map_rev func (List.nil) = Equal.refl
List.map_rev func (List.cons head tail) = 
  let ind = List.map_rev func tail
  let app = Equal.apply (x => App x (Map func [head])) ind 
  let aux = List.map_app func (Rev tail) [head]
  let chn = Equal.chain aux app
  chn

// - ind : (Equal (Map func (Rev tail)) (Rev (Map func tail)))
// - app : (Equal (App (Map func (Rev tail)) (List.cons (func head) (List.nil))) (App (Rev (Map func tail)) (List.cons (func head) (List.nil))))
// - aux : (Equal (Map func (App (Rev tail) (List.cons head (List.nil)))) (App (Map func (Rev tail)) (List.cons (func head) (List.nil))))
// - chn : (Equal (Map func (App (Rev tail) (List.cons head (List.nil)))) (App (Rev (Map func tail)) (List.cons (func head) (List.nil))))
// - Goal: (Equal (Map func (App (Rev tail) (List.cons head (List.nil)))) (App (Rev (Map func tail)) (List.cons (func head) (List.nil))))
// 2. FUNCTIONS AS DATA 63
// 2.4.2. Exercise: 2 stars, recommended (flat_map). The function map maps a
// List x to a List y using a function of type x ౏> y. We can define a similar function,
// flat_map, which maps a List x to a List y using a function func of type x ౏> List y. Your
// definition should work by ‘flattening’ the results of f, like so:

Flatten <x> (lxs: (List (List x))) : List x
Flatten List.nil = List.nil
Flatten (List.cons head tail) = App head (Flatten tail)

Flat_map <x> <y> (f: x -> List y) (l: List x) : List y
Flat_map f List.nil = List.nil 
Flat_map f l = Flatten (Map f l)

// flat_map f l = ?flat_map_rhs

Test_flat_map1 : (Equal (Flat_map  (n => [n,(+ n 1),(+ n 2)]) [1,5,10])  ([1,2,3, 5,6,7, 10,11,12]))
Test_flat_map1 = Equal.refl
// Test_flat_map2 :  Equal (Flat_map (n => [n,n,n]) [1,5,4]) [1,1,1,5,5,5,4,4,4]
// Test_flat_map2 = ?

// Lists are not the only inductive type that we can write a map function for. Here is
// the definition of map for the Option type:

Maybe_map <x> <y> (f:x -> y) (m: Maybe x) : Maybe y
Maybe_map f Maybe.none = Maybe.none
Maybe_map f (Maybe.some x) = Maybe.some (f x)

// 2.4.3. Exercise: 2 stars, optional (implicit_args). The definitions and uses of
// filter and map use implicit arguments in many places. Add explicit type parameters
// where necessary and use Idris to check that you’ve done so correctly. (This exercise
// is not to be turned in; it is probably easiest to do it on a copy of this file that you
// can throw away afterwards.)


// 2.5. Fold. An even more powerful higher-order function is called fold. This
// function is the inspiration for the ”reduce” operation that lies at the heart of
// Google’s map/reduce distributed programming framework.

// fold : (f : x ౏> y ౏> y) ౏> (l : List x) ౏> (b : y) ౏> y
// fold f List.nil b = b
// fold f (h௝௞t) b = f h (fold f t b)
Fold <x> <y> (func: x -> y -> y) (l: List x) (b: y) : y
Fold func List.nil b = b
Fold func (List.cons l head tail) b = (func head) (Fold func tail b)

// fold (+) [1,2,3,4] 0
// yields
// 1 + (2 + (3 + (4 + 0)))

// fold_example1 : fold (*) [1,2,3,4] 1 = 24
// fold_example1 = Refl

// fold_example2 : fold Booleans.andb [True,True,False,True] True = False
// fold_example2 = Refl

// fold_example3 : fold (++) [[1],List.nil,[2,3],[4]] List.nil = [1,2,3,4]
// fold_example3 = Refl

// 2.5.1. Exercise: 1 star, advanced (fold_types_different). Observe that the
// type of fold is parameterized by two type variables, x and y, and the parameter f is a binary operator that takes an x and a y and returns a y. Can you think
// of a situation where it would be useful for x and y to be different?
// -- FILL IN HERE

// 2.6. Functions That Construct Functions. Most of the higher-order functions we have talked about so far take functions as arguments. Let’s look at some
// examples that involve returning functions as the results of other functions. To begin, here is a function that takes a value x (drawn from some type x) and returns a
// function from Nat to x that yields x whenever it is called, ignoring its Nat argument.

Constfun <y> (x: y) : Nat -> y
Constfun x = y => x

Ftrue : Nat -> Bool
Ftrue = Constfun Bool.true

Constfun_example1 : Equal Bool ((Ftrue) 0n) Bool.true
Constfun_example1 = Equal.refl

Constfun_example2 : Equal Nat ((Constfun 5n) 99n) 5n
Constfun_example2 = Equal.refl

Plus3 : Nat -> Nat
Plus3 = n => Nat.add 3n n

Test_plus3_1 : Equal Nat ((Plus3) 4n) 7n
Test_plus3_1 = Equal.refl

Test_plus3_2 : Equal Nat (Doit3times (Plus3) 0n) 9n
Test_plus3_2 = Equal.refl

Test_plus3_3 : Equal Nat (Doit3times (Plus3) 0n) 9n
Test_plus3_3 = Equal.refl

// Test_plus3_3 : doit3times (plus 3) 0 = 9
// Test_plus3_3 = Refl

// 3. Additional Exercise
// 3.0.1. Exercise: 2 stars (fold_length). Many common functions on lists can
// be implemented in terms of fold. For example, here is an alternative definition of
// length:
// fold_length : (l : List x) ౏> Nat
// fold_length l = fold (\_, n ౬> S n) l 0
Fold_length <x> (l: List x) : Nat
Fold_length l = Fold (n => n => (Nat.succ n)) l 0n

Test_fold_length1 : Equal Nat (Fold_length [4,7,0]) 3n
Test_fold_length1 = Equal.refl

// Prove the correctness of fold_length.
Fold_length_correct <x> (l : List x) : Equal Nat (Fold_length l) (Length l)
Fold_length_correct List.nil = Equal.refl
Fold_length_correct (List.cons head tail) = 
  let ind = Fold_length_correct tail
  let app = Equal.apply (n => Nat.succ n) ind
  app
// •   ind   : (Equal Nat (Fold (n => (n => (Nat.succ n))) tail 0n) (Length tail)) 
// •   app   : (Equal Nat (Nat.succ (Fold (n => (n => (Nat.succ n))) tail 0n)) (Nat.succ (Length tail))) 
// • Expected: (Equal Nat (Nat.succ (Fold (n => (n => (Nat.succ n))) tail 0n)) (Nat.succ (Length tail))) 

// 3.0.2. Exercise: 3 stars (fold_map). We can also define map in terms of fold.
// Finish fold_map below.
// fold_map : (f : x ౏> y) ౏> (l : List x) ౏> List y
// fold_map f l = ?fold_map_rhs
Fold_map <x> <y> (f: x -> y) (l: List x) : List y
Fold_map f l = Fold (h => t => (List.cons (f h) t)) l []

// Write down a theorem fold_map_correct in Idris stating that fold_map is correct, and
// prove it.
Fold_map_correct <x> <y> (f: x -> y) (l: List x) : Equal (List y) (Fold_map f l) (Map f l)
Fold_map_correct f List.nil = Equal.refl
Fold_map_correct f (List.cons head tail) = 
  let ind = Fold_map_correct f tail
  let app = Equal.apply (t => List.cons (f head) t) ind
  app
// •   ind   : (Equal (List y) (Fold (h => (t => (List.cons (f h) t))) tail (List.nil)) (Map f tail)) 
// •   app   : (Equal (List y) (List.cons (f head) (Fold (h => (t => (List.cons (f h) t))) tail (List.nil))) (List.cons (f head) (Map f tail))) 
// • Expected: (Equal (List y) (List.cons (f head) (Fold (h => (t => (List.cons (f h) t))) tail (List.nil))) (List.cons (f head) (Map f tail))) 

// 3.0.3. Exercise: 2 stars, advanced (currying). In Idris, a function f: a ౏> b ౏> c
// really has the type a ౏> (b ౏> c). That is, if you give f a value of type a, it will
// give you function f' : b ౏> c. If you then give f' a value of type b, it will return a
// value of type c. This allows for partial application, as in plus3. Processing a list of
// arguments with functions that return functions is called currying, in honor of the
// logician Haskell Curry.


Pair_curry <x> <y> <z> (f: (Pair x y) -> z) (x_val: x) (y_val: y) : z 
Pair_curry f x_val y_val = f (Pair.new x_val y_val)


// As an exercise, define its inverse, prod_uncurry. Then prove the theorems below to
// show that the two are inverses.

Pair_uncurry <x> <y> <z> (f: x -> y -> z) (p: Pair x y) : z
Pair_uncurry x y z f (Pair.new fst snd) = (f fst snd) 

Uncurry_curry <x> <y> <z> (f: x -> y -> z) (x_val: x) (y_val: y) : Equal z (Pair_curry (p => Pair_uncurry f p) x_val y_val) (f x_val y_val)
Uncurry_curry f x_val y_val = Equal.refl

Curry_uncurry <x> <y> <z> (f:(Pair x y) -> z) (p: Pair x y) : Equal z (Pair_uncurry (x => y => Pair_curry f x y) p) (f p)
Curry_uncurry f (Pair.new fst snd) = Equal.refl

// 3.0.4. Exercise: 2 stars, advanced (nth_error_informal). Recall the definition
// of the nth_error function:
Nth_error_informal <x> (l: List x) (n: Nat) : Maybe x
Nth_error_informal List.nil n = Maybe.none 
Nth_error_informal (List.cons head tail) Nat.zero =  Maybe.some head 
Nth_error_informal (List.cons head tail) (Nat.succ n) =  Nth_error tail n


// 3.0.5. Exercise: 4 stars, advanced (church_numerals). This exercise explores
// an alternative way of defining natural numbers, using the so-called Church numerals, named after mathematician Alonzo Church. We can represent a natural
// number n as a function that takes a function f as a parameter and returns f iterated
// n times.
// namespace Church^
// Nat : Type
// Nat = ~(nat : Type) -> (succ : nat -> nat) -> (zero : nat) -> nat

Num <x> : Type
Num x = (x -> x) -> x -> x
// Num : Type 
// Num = ~(x: Type) -> (succ: x -> x) -> (zero: x) -> x
// Nat' : {x : Type} ౏> Type
// Nat' {x} = (x ౏> x) ౏> x ౏> x

One : Num 
One = f => x => (f x)

// one f x = f x
// Similarly, two should apply f twice to its argument:
Two : Num
Two = f => x => (f (f x))
// two f x = f (f x)

// Defining zero is somewhat trickier: how can we “apply a function zero times”? The
// answer is actually simple: just return the argument untouched.
Zero : Num
Zero = f => x => x 
// zero f x = x

// More generally, a number n can be written as \f, x ౬> f (f ... (f x) ...), with n
// occurrences of f. Notice in particular how the doit3times function we’ve defined
// previously is actually just the Church representation of 3.
Three : Num
Three = f => x => (f (f (f x)))
// Three = f => x => Doit3times f x

// succ' : (n : Nat' {x}) ౏> Nat' {x}
// succ' n = ?succ__rhs
Pred (n: Num -> Num) : Num
Pred n = s => z => n ((g: Num) => (h: Num) => (h (g s))) ((u: Num) => z) ((u: Num) => u)
// λn.λf.λx. n (λg.λh. h (g f)) (λu. x) (λu. u)
Pred_1 : Equal (Pred Zero) (Zero)
Pred_1 = Equal.refl

Pred_2 : Equal (Pred Two) (One)
Pred_2 = Equal.refl

Pred_3 : Equal (Pred Three) (Two)
Pred_3 = Equal.refl

Sub (n: Num) (m: Num) : Num
Sub n m = (m (x => Pred x)) n 

Sub_1 : Equal (Sub One Zero) (One)
Sub_1 = Equal.refl

Sub_2 : Equal (Sub Two Two) (Sub One One)
Sub_2 = Equal.refl

Sub_3 : Equal (Sub Three One) Two
Sub_3 = Equal.refl
// Successor of a natural number:
Succ (n: Num) : Num //?
Succ n = s => z => s (n s z) // ????
// λn.λf.λx. f (n f x).
Succ_1 : Equal (Succ Zero) (One)
Succ_1 = Equal.refl

Succ_2 : Equal (Succ One) (Two)
Succ_2 = Equal.refl

Succ_3 : Equal (Succ Two) (Three)
Succ_3 = Equal.refl

// Addition of two natural numbers: // adicionar o tipos do lambda
Plus (n: Num) (m: Num) : Num
Plus n m = (s: Num) => (z: Num) => n s (m s z)
// λm.λn.λf.λx. m f (n f x)
// plus' : (n, m : Nat' {x}) ౏> Nat' {x}
// plus' n m = ?plus__rhs

Plus_1 : Equal (Plus One Zero) (One)
Plus_1 = Equal.refl
// plus'_1 : plus' zero one = one
// plus'_1 = ?plus__1_rhs

Plus_2 : Equal (Plus Two One) (Plus One Two)
Plus_2 = Equal.refl

// plus'_2 : plus' two three = plus' three two
// plus'_2 = ?plus__2_rhs

// plus'_3 : plus' (plus' two two) three = plus' one (plus' three three)
// plus'_3 = ?plus__3_rhs

Plus_3 : Equal (Plus (Plus Two Two) Three) (Plus One (Plus Three Three))
Plus_3 = Equal.refl

// Multiplication:
Mult (n: Num) (m: Num) : Num
Mult n m = s => z => n (m s) z
// mult' : (n, m : Nat' {x}) ౏> Nat' {x}
// mult' n m = ?mult__rhs

Mult_1 : Equal (Mult One One) One
Mult_1 = Equal.refl
// mult'_1 : mult' one one = one
// mult'_1 = ?mult__1_rhs

Mult_2 : Equal (Mult Zero (Plus Three Three)) Zero
Mult_2 = Equal.refl
// mult'_2 : mult' zero (plus' three three) = zero
// mult'_2 = ?mult__2_rhs

Mult_3 : Equal (Mult Two Three) (Plus Three Three)
Mult_3 = Equal.refl
// mult'_3 : mult' two three = plus' three three
// mult'_3 = ?mult__3_rhs

// Exponentiation:
// Edit the hint. Can’t make it work with exp' : (n, m : Nat' {x}) ౏> Nat' {x}.
// (Hint: Polymorphism plays a crucial role here. However, choosing the right type to
// iterate over can be tricky. If you hit a “Universe inconsistency” error, try iterating
// over a different type: Nat' itself is usually problematic.)
Exp (n: Num) (m: Num) : Num
Exp n m = s => z =>  m n s z
// exp' : (n : Nat' {x}) ౏> (m : Nat' {x=x౏>x}) ౏> Nat' {x}
// exp' n m = ?exp__rhs

// This won’t typecheck under this signature of exp because of 2 instances of two
Exp_1 : Equal (Exp Two Two) (Plus Two Two)
Exp_1 = Equal.refl
// -- exp'_1 : exp' two two = plus' two two
// -- exp'_1 = ?exp__1_rhs
Exp_2 : Equal (Exp Three Two) (Plus (Mult Two (Mult Two Two)) One)
Exp_2 = Equal.refl
// exp'_2 : exp' three two = plus' (mult' two (mult' two two)) one
// exp'_2 = ?exp__2_rhs
Exp_3 : Equal (Exp Three Zero) One
Exp_3 = Equal.refl
// exp'_3 : exp' three zero = one
// exp'_3 = ?exp__3_rhs


// MapSix : List Nat
// MapSix = (List.cons Nat (U60.to_nat 1)
// 	(List.cons Nat (U60.to_nat 1)
// 	(List.cons Nat (U60.to_nat 2)
// 	(List.cons Nat (U60.to_nat 3)
// 	(List.cons Nat (U60.to_nat 4)
// 	(List.cons Nat (U60.to_nat 5)
// 	(List.cons Nat (U60.to_nat 6)((List.nil Nat)))))))))
// Main {
//   let a =  Fold_map (x => (+ 3 x)) [1,2,3] 
//   let b =  Map (x => (+ 3 x)) [1,2,3] 
//   a
// }