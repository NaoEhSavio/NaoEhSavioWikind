// 1.1. Polymorphic Lists.
// data BoolList : Type where
// BoolNil : BoolList
// BoolCons : Bool ౏> BoolList ౏> BoolList
BoolList : Type
BoolList = (List Bool)

// Data List : (x : Type) ౏> Type where
// Nil : List x
// Cons : x ౏> List x ౏> List x
List <a: Type> : Type
List.nil <a> : List a  
List.cons <a> (head: a) (tail: List a) : List a  

// repeat : (x_ty : Type) ౏> (x : x_ty) ౏> (count : Nat) ౏> List x_ty
// repeat x_ty x Z = Nil
// repeat x_ty x (S count') = x ௝௞ repeat x_ty x count'
List.repeat <x_ty: Type> (x: x_ty) (count: Nat) : List x_ty
List.repeat x_ty x Nat.zero = (List.nil x_ty)
List.repeat x_ty x (Nat.succ count) = List.cons x (List.repeat x_ty x count)

// test_repeat1 : repeat Nat 4 2 = 4 ௝௞ (4 ௝௞ Nil)
// test_repeat1 = Refl
Test_repeat1 : Equal (List.repeat Nat (U60.to_nat 4) (U60.to_nat 2)) (List.cons (U60.to_nat 4) (List.cons (U60.to_nat 4) (List.nil Nat)))
Test_repeat1 = Equal.refl

// test_repeat2 : repeat Bool False 1 = False ௝௞ Nil
// test_repeat2 = Refl
Test_repeat2 : Equal BoolList (List.repeat Bool (Bool.false) (U60.to_nat 1)) (List.cons (Bool.false) (List.nil Bool))
Test_repeat2 = Equal.refl

// 1.1.1. Exercise: 2 stars (mumble_grumble).
// Explain implicits and {x=foo} syntax first? Move after the ”Supplying Type
// Arguments Explicitly” section?
// namespace MumbleGrumble
// Consider the following two inductively defined types.
// data Mumble : Type where
// A : Mumble
// B : Mumble ౏> Nat ౏> Mumble
// C : Mumble
// data Grumble : (x : Type) ౏> Type where
// D : Mumble ౏> Grumble x
// E : x ౏> Grumble x
// Which of the following are well-typed elements of Grumble x for some type x?
// • D (B A 5)
// • D (B A 5) {x=Mumble}
// • D (B A 5) {x=Bool}
// • E True {x=Bool}
// • E (B C 0) {x=Mumble}
// • E (B C 0) {x=Bool}
// • C
// -- FILL IN HERE

// repeat' : {x_ty : Type} ౏> (x : x_ty) ౏> (count : Nat) ౏> List x_ty
// repeat' x Z = Nil
// repeat' x (S count') = x ௝௞ repeat' x count'
// List.repeat <x_ty: Type> (x: x_ty) (count: Nat) : List x_ty
// List.repeat x_ty x Nat.zero = (List.nil x_ty)
// List.repeat x_ty x (Nat.succ count) = List.cons x (List.repeat x_ty x count)

// data List' : {x : Type} ౏> Type where
// Nil' : List'
// Cons' : x ౏> List' ౏> List'
// List <a: Type> : Type
// List.nil <a> : List a  
// List.cons <a> (head: a) (tail: List a) : List a 

// 1.1.4. Implicit Arguments

// repeat'' : (x : x_ty) ౏> (count : Nat) ౏> List x_ty
// repeat'' x Z = Nil
// repeat'' x (S count') = x ௝௞ repeat'' x count'
// List.repeat <x_ty: Type> (x: x_ty) (count: Nat) : List x_ty
// List.repeat x_ty x Nat.zero = (List.nil x_ty)
// List.repeat x_ty x (Nat.succ count) = List.cons x (List.repeat x_ty x count)

// app : (l1, l2 : List x) ౏> List x
// app Nil l2 = l2
// app (h௝௞t) l2 = h ௝௞ app t l2
List.app <a: Type> (l1: List a) (l2: List a) : List a
List.app a (List.nil ) l2 = l2
List.app a (List.cons x head tail) l2 = List.cons head (List.app tail l2) 

// rev : (l : List x) ౏> List x
// rev [] = []
// rev (h௝௞t) = app (rev t) (h௝௞Nil)
List.rev <x: Type> (l: List x) : List x
List.rev [] = []                                         // #######[head]#######
List.rev (List.cons x head tail) = List.app (List.rev tail) (List.cons head []) 

// length :l (l : List x) ౏> Nat
// length [] = Z
// length (_௝௞l') = S (length l')
List.length <x: Type> (l: List x) : Nat
List.length [] = Nat.zero
List.length (List.cons x head tail) = Nat.succ (List.length tail)
// test_rev1 : rev (1௝௞2௝௞[]) = 2௝௞1௝௞[]
// test_rev1 = Refl
Test_rev1 : Equal (List.rev ([])) ([])
Test_rev1 = Equal.refl
// test_rev2 : rev (True௝௞[]) = True௝௞[]
// test_rev2 = Refl
Test_rev2 : Equal (List.rev ([])) ([])
Test_rev2 = Equal.refl
// test_length1 : length (1௝௞2௝௞3௝௞[]) = 3
// test_length1 = Refl
Test_length1 : Equal (List.length ([])) (Nat.zero)
Test_length1 = Equal.refl
// 1.1.6. Exercise: 2 stars, optional (poly_exercises). Here are a few simple exercises, just like ones in the Lists chapter, for practice with polymorphism. Complete
// the proofs below.
// app_nil_r : (l : List x) ౏> l ++ [] = l
// app_nil_r l = ?app_nil_r_rhs
App_nil_r <x: Type> (l: List x) : (Equal (List.concat l []) l)

// app_assoc : (l, m, n : List a) ౏> l ++ m ++ n = (l ++ m) ++ n
// app_assoc l m n = ?app_assoc_rhs
App_assoc <a: Type> (l: List a) (m: List a) (n: List a) : (Equal (List.concat l (List.concat m n)) (List.concat (List.concat l m) n)) 

// app_length : (l1, l2 : List x) ౏> length (l1 ++ l2) = length l1 + length l2
// app_length l1 l2 = ?app_length_rhs
App_length <x: Type> (l1: List x) (l2: List x) : (Equal Nat (List.length (List.concat l1 l2)) (Nat.add (List.length l1) (List.length l2)))

// 1.1.7. Exercise: 2 stars, optional (more_poly_exercises). Here are some slightly more interesting ones…
// rev_app_distr : (l1, l2 : List x) ౏> rev (l1 ++ l2) = rev l2 ++ rev l1
// rev_app_distr l1 l2 = ?rev_app_distr_rhs
Rev_app_distr <x: Type> (l1: List x) (l2: List x) : (Equal (List x) (List.rev (List.app l1 l2)) (List.app (List.rev l2) (List.rev l1)))
Rev_app_distr (List.cons x xs) l2 =
  let ind = Rev_app_distr xs l2

  ?

// - Goal  : (Equal (List a0_) (List.app _ (List.rev _ (List.concat _ xs l2)) (List.cons _ x (List.nil _))) (List.concat _ (List.rev x1_ l2) (List.app _ (List.rev _ xs) (List.cons _ x (List.nil _)))))
// rev_involutive : (l : List x) ౏> rev (rev l) = l
// rev_involutive l = ?rev_involutive_rhs
Rev_involutive <x: Type> (l: List x) : (Equal (List.rev (List.rev l)) l)

// 1.2. Polymorphic Pairs. Following the same pattern, the type definition
// we gave in the last chapter for pairs of numbers can be generalized to polymorphic
// pairs, often called products:
// data Prod : (x, y : Type) ౏> Type where
// PPair : x ౏> y ౏> Prod x 
Prod <x: Type> <y: Type> : Type
Prod x y = (Pair x y)

// fst : (p : x*y) ౏> x
// fst (x,y) = x
Prod.fst <x: Type> <y: Type> (P: Prod x y) : x
Prod.fst (Pair.new fst snd) = fst

// snd : (p : x*y) ౏> y
// snd (x,y) = y
Prod.snd <x: Type> <y: Type> (P: Prod x y) : y
Prod.snd (Pair.new fst snd) = snd

// zip : (lx : List x) ౏> (ly : List y) ౏> List (x*y)
// zip [] _ = []
// zip _ [] = []
// zip (x௝௞tx) (y௝௞ty) = (x,y) ௝௞ zip tx ty
List.zip <x: Type> <y: Type> (lx: List x) (ly: List y) : (List (Prod x y))
List.zip [] ly = []
List.zip lx [] = []
List.zip x y (List.cons lx lx.head lx.tail) (List.cons ly ly.head ly.tail) = List.cons (Pair.new lx.head ly.head) (List.zip lx.tail ly.tail)

// 1.2.1. Exercise: 1 star, optional (combine_checks). Try answering the following questions on paper and checking your answers in Idris:
// • What is the type of zip (i.e., what does :t zip print?)
// • What does combine [1,2] [False,False,True,True] print?

// 1.2.2. Exercise: 2 stars, recommended (split). The function split is the right
// inverse of zip: it takes a list of pairs and returns a pair of lists. In many functional
// languages, it is called unzip.

// Fill in the definition of split below. Make sure it passes the given unit test.

// split : (l : List (x*y)) ౏> (List x) * (List y)
// split l = ?split_rhs
List.split <x: Type> <y: Type> (l: List (Prod x y)) : Prod (List x) (List y)
List.split  [] = Pair.new [] []
// List.split x y (List.cons pair tail) = ?

// List.unzip<A: Type, B: Type>(xs: List<Pair<A,B>>): Pair<List<A>,List<B>>
//   case xs {
//     nil: {List.nil!, List.nil!},
//     cons: 
//       let rec = List.unzip!!(xs.tail)
//       open xs.head
//       open rec
//       {xs.head.fst & rec.fst, xs.head.snd & rec.snd}
//   }

// test_split : split [(1,False),(2,False)] = ([1,2],[False,False])
// test_split = ?test_split_rhs
// □
// 1.2.3. Polymorphic Options. One last polymorphic type for now: polymorphic
// options, which generalize NatOption from the previous chapter:
// data Option : (x : Type) ౏> Type where
// Some : x ౏> Option x
// None : Option x

Option <x> : Type 
Option x = Maybe x

// In Idris’ standard library this type is called Maybe, with constructors Just x and
// Nothing.
// We can now rewrite the nth_error function so that it works with any type of lists.

// nth_error : (l : List x) ౏> (n : Nat) ౏> Option x
// nth_error [] n = None
// nth_error (a௝௞l') n = if n తథ 0 then Some a else nth_error l' (pred n)
Nth_error <x> (l: List x) (n: Nat) : Option x
Nth_error x [] n = (Maybe.none x)
Nth_error x (List.cons l head tail) n = if (Nat.equal n Nat.zero) {Maybe.some head} else {(Nth_error tail (Nat.pred n))}

// test_nth_error1 : nth_error [4,5,6,7] 0 = Some 4
// test_nth_error1 = Refl

// test_nth_error2 : nth_error [[1],[2]] 1 = Some [2]
// test_nth_error2 = Refl

// test_nth_error3 : nth_error [True] 2 = None
// test_nth_error3 = Refl

// 1.2.4. Exercise: 1 star, optional (hd_error_poly). Complete the definition of
// a polymorphic version of the hd_error function from the last chapter. Be sure that
// it passes the unit tests below.

// hd_error : (l : List x) ౏> Option x
// hd_error l = ?hd_error_rhs
Hd_error <x> (l: List x) : Option x
Hd_error x (List.nil l) = (Maybe.none x)
Hd_error x (List.cons l head tail) = (Maybe.some head)

// test_hd_error1 : hd_error [1,2] = Some 1
// test_hd_error1 = ?test_hd_error1_rhs

// test_hd_error2 : hd_error [[1],[2]] = Some [1]
// test_hd_error2 = ?test_hd_error2_rhs

// 2. Functions as Data
// 2.1. Higher-Order Functions. Functions that manipulate other functions
// are often called higher-order functions. Here’s a simple one:
// doit3times : (f: x ౏> x) ౏> (n : x) ౏> x
// doit3times f n = f (f (f n))
Doit3times <x> (func: x -> x) (n: x) : x
Doit3times x func n = (func (func (func n)))


Numbers.minusTwo (n: Nat) : Nat
Numbers.minusTwo Nat.zero = Nat.zero
Numbers.minusTwo (Nat.succ Nat.zero) = Nat.zero
Numbers.minusTwo (Nat.succ (Nat.succ k)) = k

// test_doit3times : doit3times Numbers.minusTwo 9 = 3
// test_doit3times = Refl
Test_doit3times : (Equal (Doit3times (x => Numbers.minusTwo x) (U60.to_nat 9)) (U60.to_nat 3))
Test_doit3times = Equal.refl

// test_doit3times' : doit3times Bool.not True = False
// test_doit3times' = Refl
Test_doit3times2 : (Equal (Doit3times (x => Bool.not x) Bool.true) Bool.false)
Test_doit3times2 = Equal.refl
// - Goal: (Equal _ Bool.false Bool.false)
// 2.2. Filter. Here is a more useful higher-order function, taking a list of xs
// and a predicate on x (a function from x to Bool) and “filtering” the list, returning
// a new list containing just those elements for which the predicate returns True.

// filter : (test : x ౏> Bool) ౏> (l: List x) ౏> List x
// filter test [] = []
// filter test (h௝௞t) = if test h then h ௝௞ (filter test t) else filter test t
List.filter <x> (func: x -> Bool) (l: (List x)) : (List x)
List.filter x func (List.nil l) = (List.nil)
List.filter x func (List.cons l head tail) = 
  Bool.match (func head) ( x => _ ) (List.cons head (List.filter func tail)) (List.filter func tail)
    // if (func head) {List.cons head (List.filter func tail)}
    //     else {List.filter func tail}

// (This is how it’s defined in Idris’s stdlib, too.)
// For example, if we apply filter to the predicate evenb and a list of numbers l, it
// returns a list containing just the even members of l.

// test_filter1 : filter Numbers.evenb [1,2,3,4] = [2,4]
// test_filter1 = Refl

// length_is_1 : (l: List x) ౏> Bool
// length_is_1 l = length l తథ 1
Length_is_1 <x> (l: List x ) : Bool
Length_is_1 l = Nat.equal (List.length l) (Nat.succ Nat.zero)

// test_filter2 : filter Poly.length_is_1 [ [1,2], [3], [4], [5,6,7], [], [8] ] = [ [3], [4], [8] ] 
// test_filter2 = Refl
Nat.odd (n: Nat) : Bool
Nat.odd Nat.zero = Bool.false
Nat.odd (Nat.succ Nat.zero) = Bool.true
Nat.odd (Nat.succ (Nat.succ k)) = Nat.odd k

// countoddmembers' : (l: List Nat) ౏> Nat
// countoddmembers' l = length (filter Numbers.oddb l)
Countoddmembers (l: List Nat) : Nat
Countoddmembers l = List.length (List.filter (x => Nat.odd x) l)

// test_countoddmembers'1 : countoddmembers' [1,0,3,1,4,5] = 4
// test_countoddmembers'1 = Refl

// test_countoddmembers'2 : countoddmembers' [0,2,4] = 0
// test_countoddmembers'2 = Refl

// test_countoddmembers'3 : countoddmembers' Nil = 0
// test_countoddmembers'3 = Refl

// 2.3. Anonymous Functions. 
// test_anon_fun' : doit3times (\n ౬> mult n n) 2 = 256
// test_anon_fun' = Refl

// The expression \n ౬> mult n n can be read as “the function that, given a number n,
// yields n * n.”
// Here is the filter example, rewritten to use an anonymous function.

// test_filter2' : filter (\l ౬> length l తథ 1)
// [ [1,2], [3], [4], [5,6,7], [], [8] ]
// = [ [3], [4], [8] ]
// test_filter2' = Refl

// 2.3.1. Exercise: 2 stars (filter_even_gt7). Use filter (instead of function definition) to write an Idris function filter_even_gt7 that takes a list of natural numbers
// as input and returns a list of just those that are even and greater than 7.

// filter_even_gt7 : (l : List Nat) ౏> List Nat
// filter_even_gt7 l = ?filter_even_gt7_rhs

// test_filter_even_gt7_1 : filter_even_gt7 [1,2,6,9,10,3,12,8] = [10,12,8]
// test_filter_even_gt7_1 = ?test_filter_even_gt7_1_rhs

// test_filter_even_gt7_2 : filter_even_gt7 [5,2,6,19,129] = []
// test_filter_even_gt7_2 = ?test_filter_even_gt7_2_rhs

// 2.3.2. Exercise: 3 stars (partition). Use filter to write an Idris function partition:
// partition : (test : x ౏> Bool) ౏> (l : List x) ౏> (List x) * (List x)
// partition f xs = ?partition_rhs

// Given a set x, a test function of type x ౏> Bool and a List x, partition should return a
// pair of lists. The first member of the pair is the sublist of the original list containing
// the elements that satisfy the test, and the second is the sublist containing those
// that fail the test. The order of elements in the two sublists should be the same as
// their order in the original list.

// test_partition1 : partition Numbers.oddb [1,2,3,4,5] = ([1,3,5], [2,4])
// test_partition1 = ?test_partition1_rhs

// test_partition2 : partition (\x ౬> False) [5,9,0] = (([], [5,9,0]))
// test_partition2 = ?test_partition2_rhs

// 2.4. Map. Another handy higher-order function is called map.
// map : (f : x ౏> y) ౏> (l : List x) ౏> List y
// map f [] = []
// map f (h௝௞t) = (f h) ௝௞ map f t

List.map <x> <y> (func: x -> y) (l: (List x)): (List y)
List.map x y func [] = []
List.map x y func (List.cons l head tail) = List.cons (func(head)) (List.map func tail)

// It takes a function f and a list l = [n1, n2, n3, ...] and returns the list
// [f n1, f n2, f n3,...], where f has been applied to each element of l in turn. For
// example:

// test_map1 : map (\x ౬> plus 3 x) [2,0,2] = [5,3,5]
// test_map1 = Refl

// The element types of the input and output lists need not be the same, since map
// takes two type arguments, x and y; it can thus be applied to a list of numbers and
// a function from numbers to booleans to yield a list of booleans

// test_map2 : map Numbers.oddb [2,1,2,5] = [False,True,False,True]
// test_map2 = Refl

// It can even be applied to a list of numbers and a function from numbers to lists
// of booleans to yield a list of lists of booleans:

// test_map3 : map (\n ౬> [evenb n, oddb n]) [2,1,2,5]
// = [[True,False],[False,True],[True,False],[False,True]]
// test_map3 = Refl

// 2.4.1. Exercise: 3 stars (map_rev). Show that map and rev commute. You may
// need to define an auxiliary lemma.
// map_rev : (f : x ౏> y) ౏> (l : List x) ౏> map f (rev l) = rev (map f l)
// map_rev f l = ?map_rev_rhs



// 2. FUNCTIONS AS DATA 63
// 2.4.2. Exercise: 2 stars, recommended (flat_map). The function map maps a
// List x to a List y using a function of type x ౏> y. We can define a similar function,
// flat_map, which maps a List x to a List y using a function f of type x ౏> List y. Your
// definition should work by ‘flattening’ the results of f, like so:

// flat_map (\n ౬> [n,n+1,n+2]) [1,5,10] = [1,2,3, 5,6,7, 10,11,12]
// flat_map : (f : x ౏> List y) ౏> (l : List x) ౏> List y
// flat_map f l = ?flat_map_rhs

// test_flat_map1 : flat_map (\n ౬> [n,n,n]) [1,5,4] = [1,1,1, 5,5,5, 4,4,4]
// test_flat_map1 = ?test_flat_map1_rhs

// Lists are not the only inductive type that we can write a map function for. Here is
// the definition of map for the Option type:

// option_map : (f : x ౏> y) ౏> (xo : Option x) ౏> Option y
// option_map f None = None
// option_map f (Some x) = Some (f x)

// 2.4.3. Exercise: 2 stars, optional (implicit_args). The definitions and uses of
// filter and map use implicit arguments in many places. Add explicit type parameters
// where necessary and use Idris to check that you’ve done so correctly. (This exercise
// is not to be turned in; it is probably easiest to do it on a copy of this file that you
// can throw away afterwards.)


// 2.5. Fold. An even more powerful higher-order function is called fold. This
// function is the inspiration for the ”reduce” operation that lies at the heart of
// Google’s map/reduce distributed programming framework.

// fold : (f : x ౏> y ౏> y) ౏> (l : List x) ౏> (b : y) ౏> y
// fold f [] b = b
// fold f (h௝௞t) b = f h (fold f t b)

List.fold <x> <y> (func: x -> y -> y) (l: List x) (b: y) : y
List.fold x y func [] b = b
List.fold x y func (List.cons l head tail) b = (func head) (List.fold func tail b)

// List.foldr <a> <b> (nil: b) (cons: a -> b -> b) (xs: List a) : List b
// List.foldr a b nil cons (List.nil  x.a)         = []
// List.foldr a b nil cons (List.cons x.a x.h x.t) = List.cons (cons x.h) (List.foldr nil cons x.t)

// List.fold <a> <p> (xs: List a) : p -> (a -> p -> p) -> p
// List.fold a p (List.nil t)            = nil => cons => nil
// List.fold a p (List.cons t head tail) = nil => cons => cons head ((List.fold a p tail) nil cons)

MapTri : (List Nat)
MapTri = (List.cons Nat (U60.to_nat 1)
	(List.cons Nat (U60.to_nat 2)
	(List.cons Nat (U60.to_nat 3)((List.nil Nat)))))

// fold (+) [1,2,3,4] 0
// yields
// 1 + (2 + (3 + (4 + 0)))

// fold_example1 : fold (*) [1,2,3,4] 1 = 24
// fold_example1 = Refl

// fold_example2 : fold Booleans.andb [True,True,False,True] True = False
// fold_example2 = Refl

// fold_example3 : fold (++) [[1],[],[2,3],[4]] [] = [1,2,3,4]
// fold_example3 = Refl

// 2.5.1. Exercise: 1 star, advanced (fold_types_different). Observe that the
// type of fold is parameterized by two type variables, x and y, and the parameter f is a binary operator that takes an x and a y and returns a y. Can you think
// of a situation where it would be useful for x and y to be different?
// -- FILL IN HERE

// 2.6. Functions That Construct Functions. Most of the higher-order functions we have talked about so far take functions as arguments. Let’s look at some
// examples that involve returning functions as the results of other functions. To begin, here is a function that takes a value x (drawn from some type x) and returns a
// function from Nat to x that yields x whenever it is called, ignoring its Nat argument.

// constfun : (x : x_ty) ౏> Nat ౏> x_ty
// constfun x = \k ౬> x

// ftrue : Nat ౏> Bool
// ftrue = constfun True

// constfun_example1 : ftrue 0 = True
// constfun_example1 = Refl

// constfun_example2 : (constfun 5) 99 = 5
// constfun_example2 = Refl

// plus3 : Nat ౏> Nat
// plus3 = plus 3

// test_plus3 : plus3 4 = 7
// test_plus3 = Refl

// test_plus3' : doit3times Poly.plus3 0 = 9
// test_plus3' = Refl

// test_plus3'' : doit3times (plus 3) 0 = 9
// test_plus3'' = Refl

// 3. Additional Exercise
// 3.0.1. Exercise: 2 stars (fold_length). Many common functions on lists can
// be implemented in terms of fold. For example, here is an alternative definition of
// length:
// fold_length : (l : List x) ౏> Nat
// fold_length l = fold (\_, n ౬> S n) l 0

// test_fold_length1 : fold_length [4,7,0] = 3
// test_fold_length1 = Refl

// Prove the correctness of fold_length.
// fold_length_correct : (l : List x) ౏> fold_length l = length l
// fold_length_correct l = ?fold_length_correct_rhs

// 3.0.2. Exercise: 3 stars (fold_map). We can also define map in terms of fold.
// Finish fold_map below.
// fold_map : (f : x ౏> y) ౏> (l : List x) ౏> List y
// fold_map f l = ?fold_map_rhs

// Write down a theorem fold_map_correct in Idris stating that fold_map is correct, and
// prove it.
// fold_map_correct : ?fold_map_correct
// □
// 3.0.3. Exercise: 2 stars, advanced (currying). In Idris, a function f: a ౏> b ౏> c
// really has the type a ౏> (b ౏> c). That is, if you give f a value of type a, it will
// give you function f' : b ౏> c. If you then give f' a value of type b, it will return a
// value of type c. This allows for partial application, as in plus3. Processing a list of
// arguments with functions that return functions is called currying, in honor of the
// logician Haskell Curry.

// prod_curry : (f : (x * y) ౏> z) ౏> (x_val : x) ౏> (y_val : y) ౏> z
// prod_curry f x_val y_val = f (x_val, y_val)
// As an exercise, define its inverse, prod_uncurry. Then prove the theorems below to
// show that the two are inverses.

// prod_uncurry : (f : x ౏> y ౏> z) ౏> (p : x * y) ౏> z
// prod_uncurry f p = ?prod_uncurry_rhs

// test_map2' : map (\x ౬> plus 3 x) [2,0,2] = [5,3,5]
// test_map2' = Refl

// uncurry_curry : (f : x ౏> y ౏> z) ౏> (x_val : x) ౏> (y_val : y) ౏>
// prod_curry (prod_uncurry f) x_val y_val = f x_val y_val
// uncurry_curry f x_val y_val = ?uncurry_curry_rhs

// curry_uncurry : (f : (x * y) ౏> z) ౏> (p : x * y) ౏>
// prod_uncurry (prod_curry f) p = f p
// curry_uncurry f p = ?curry_uncurry_rhs


// 3.0.4. Exercise: 2 stars, advanced (nth_error_informal). Recall the definition
// of the nth_error function:
// nth_error : (l : List x) ౏> (n : Nat) ౏> Option x
// nth_error [] n = None
// nth_error (a௝௞l') n = if n తథ 0 then Some a else nth_error l' (pred n)

// n ౏> l ౏> length l = n ౏> nth_error l n = None

// 3.0.5. Exercise: 4 stars, advanced (church_numerals). This exercise explores
// an alternative way of defining natural numbers, using the so-called Church numerals, named after mathematician Alonzo Church. We can represent a natural
// number n as a function that takes a function f as a parameter and returns f iterated
// n times.
// namespace Church
// Nat' : {x : Type} ౏> Type
// Nat' {x} = (x ౏> x) ౏> x ౏> x

// one : Nat'
// one f x = f x
// Similarly, two should apply f twice to its argument:
// two : Nat'
// two f x = f (f x)

// Defining zero is somewhat trickier: how can we “apply a function zero times”? The
// answer is actually simple: just return the argument untouched.
// zero : Nat'
// zero f x = x

// More generally, a number n can be written as \f, x ౬> f (f ... (f x) ...), with n
// occurrences of f. Notice in particular how the doit3times function we’ve defined
// previously is actually just the Church representation of 3.
// three : Nat'
// three = doit3times

// Successor of a natural number:
// succ' : (n : Nat' {x}) ౏> Nat' {x}
// succ' n = ?succ__rhs

// succ'_1 : succ' zero = one
// succ'_1 = ?succ__1_rhs

// succ'_2 : succ' one = two
// succ'_2 = ?succ__2_rhs

// succ'_3 : succ' two = three
// succ'_3 = ?succ__3_rhs

// Addition of two natural numbers:
// plus' : (n, m : Nat' {x}) ౏> Nat' {x}
// plus' n m = ?plus__rhs

// plus'_1 : plus' zero one = one
// plus'_1 = ?plus__1_rhs

// plus'_2 : plus' two three = plus' three two
// plus'_2 = ?plus__2_rhs

// plus'_3 : plus' (plus' two two) three = plus' one (plus' three three)
// plus'_3 = ?plus__3_rhs

// Multiplication:
// mult' : (n, m : Nat' {x}) ౏> Nat' {x}
// mult' n m = ?mult__rhs

// mult'_1 : mult' one one = one
// mult'_1 = ?mult__1_rhs

// mult'_2 : mult' zero (plus' three three) = zero
// mult'_2 = ?mult__2_rhs

// mult'_3 : mult' two three = plus' three three
// mult'_3 = ?mult__3_rhs

// Exponentiation:
// Edit the hint. Can’t make it work with exp' : (n, m : Nat' {x}) ౏> Nat' {x}.
// (Hint: Polymorphism plays a crucial role here. However, choosing the right type to
// iterate over can be tricky. If you hit a “Universe inconsistency” error, try iterating
// over a different type: Nat' itself is usually problematic.)

// exp' : (n : Nat' {x}) ౏> (m : Nat' {x=x౏>x}) ౏> Nat' {x}
// exp' n m = ?exp__rhs

// This won’t typecheck under this signature of exp because of 2 instances of two
// -- exp'_1 : exp' two two = plus' two two
// -- exp'_1 = ?exp__1_rhs

// exp'_2 : exp' three two = plus' (mult' two (mult' two two)) one
// exp'_2 = ?exp__2_rhs

// exp'_3 : exp' three zero = one
// exp'_3 = ?exp__3_rhs